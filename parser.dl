/**
 * Identifiers
 */

.type Identifier <: symbol

.type IdentifierList = [
    head: Identifier,
    tail: IdentifierList
]

.type IdentifierOptional = [
    id: Identifier
]

/**
 * Compilation unit
 */

.type VariableDeclaration = VariableDeclaration {}

.type Dimension = Dimension { annotations: AnnotationList }

.type DimensionList = [
    key: Dimension,
    value: DimensionList
]

.type VariableDeclarationList = [
    key: VariableDeclaration,
    value: VariableDeclarationList
]

.type PackageDeclaration =
    PackageDeclaration { modifiers: AnnotationList, ids: IdentifierList }

.type ModuleDirective = ModuleDirective {}

.type ImportDeclaration =
      Import { s: IdentifierList }
    | ImportOnDemandFrom { s: IdentifierList }

.type ImportDeclarationList = [
    key: ImportDeclaration,
    value: ImportDeclarationList
]

.type CompilationUnit =
    OrdinaryCompilationUnit {
        package: PackageDeclaration,
        imports: ImportDeclarationList,
        declarations: DeclarationList
    }
    | ModularCompilationUnit {}

/**
 * Annotations
 */

.type ElementValue = ElementValueExpression {e: Expression}
                   | ElementValueAnnotation {a: Annotation}
// TODO ElementValueArrayInitializer                   

.type ElementValuePair = [
    key: Identifier,
    value: ElementValue
]

.type ElementValuePairList = [
    head: ElementValuePair,
    tail: ElementValuePairList
]

.type Annotation = [
    name: IdentifierList,
    pairs: ElementValuePairList
]

.type AnnotationList = [
    name: Annotation,
    pairs: AnnotationList
]

/**
 * Expressions
 */

.type Expression =
      Add                   {e1: Expression, e2: Expression}
    | And                   {e1: Expression, e2: Expression}
    | ArrayInitializer      {e: ExpressionList}
    | Assign                {e1: Expression, s: symbol, e2: Expression}
    | BitwiseAnd            {e1: Expression, e2: Expression}
    | BitwiseExclOr         {e1: Expression, e2: Expression}
    | BitwiseInclOr         {e1: Expression, e2: Expression}
    | BitwiseNot            {e: Expression}
    | Div                   {e1: Expression, e2: Expression}
    | Equal                 {e1: Expression, e2: Expression}
    | Identifier            {id: Identifier}
    | Lambda                {p: LambdaParameters, b: LambdaBody}
    | LessThan              {e1: Expression, e2: Expression}
    | Literal               {}
    | MethodInvocation      {id: Identifier, e: ExpressionList}
    | Mod                   {e1: Expression, e2: Expression}
    | Mul                   {e1: Expression, e2: Expression}
    | Not                   {e: Expression}
    | NotEqual              {e1: Expression, e2: Expression}
    | Number                {n: number}
    | Or                    {e1: Expression, e2: Expression}
    | PostDecrement         {e: Expression}
    | PostIncrement         {e: Expression}
    | PreDecrement          {e: Expression}
    | PreIncrement          {e: Expression}
    | ShiftLeft             {e1: Expression, e2: Expression}
    | ShiftRight            {e1: Expression, e2: Expression}
    | ShiftRightUnsigned    {e1: Expression, e2: Expression}
    | Sub                   {e1: Expression, e2: Expression}
    | SwitchExpr            {e: Expression, s: SwitchRuleList}
    | This                  {}

.type ExpressionOptional = [
    expr: Expression
]

.type ExpressionList = [
    head: Expression,
    tail: ExpressionList
]

.type LambdaBody =
      LambdaBodyExpression {e: Expression}
    | LambdaBodyBlock      {e: Statement}

.type LambdaParameters = symbol

/**
 * Statements
 */

.type Statement =
      Assert                {e: Expression}
    | AssertDetailed        {e1: Expression, e2: Expression}
    | Block                 {s: StatementList}
    | Do                    {e: Expression, s: Statement}
    | Empty                 {}
    | Label                 {id: Identifier, s: Statement}
    | IfThen                {e: Expression, s: Statement}
    | IfThenElse            {e: Expression, s1: Statement, s2: Statement}
    | Continue              {e: IdentifierOptional}
    | Break                 {e: IdentifierOptional}
    | Return                {e: ExpressionOptional}
    | Throw                 {e: Expression}
    | Switch                {e: Expression, s: SwitchRuleList}
    | Synchronized          {e: Expression, s: Statement}
    | While                 {e: Expression, s: Statement}
    | ExpressionStatement   {e: Expression}
    | Yield                 {e: Expression}

.type StatementList = [
    head: Statement,
    tail: StatementList
]

.type SwitchLabel =
      SwitchCase {e: ExpressionList}
    | SwitchDefault {}

.type SwitchRule =
      SwitchRuleExpression {label: SwitchLabel, s: Expression}
    | SwitchRuleBlock      {label: SwitchLabel, s: Statement}
    | SwitchRuleThrow      {label: SwitchLabel, s: Statement}

.type SwitchRuleList = [
    head: SwitchRule,
    tail: SwitchRuleList
]

/**
 * Types
 */

.type Type =
      TypeParameter {}
    | Boolean {}
    | Byte {}
    | Short {}
    | Int {}
    | Long {}
    | Var {}
    | Void {}
    | Char {}
    | Float {}
    | Double {}
    | ClassType {}

.type TypeOptional = [
    t: Type
]
         
.type TypeList = [
    head: Type,
    tail: TypeList
]

/**
 * These are constructs that may occur inside a ClassBody
 */
.type Declaration =
      ClassDeclaration {
        modifiers:  IdentifierList,
        id:         Identifier,
        superclass: TypeOptional,
        body:       DeclarationList
      }
    | InterfaceDeclaration {
        modifiers:  IdentifierList,
        id:         Identifier
      }
    | InstanceInitializerDeclaration {
        statement:  Statement
      }
    | MethodDeclaration {
        modifiers:  IdentifierList,
        header:     MethodHeader,
        body:       Statement
      }
    | EmptyDeclaration {}

.type MethodHeader = MethodHeader {
    result: Type
}

.type DeclarationList = [
    head: Declaration,
    tail: DeclarationList
]

/**
 * Inputs
 **************************************************************************/

.input token
.decl token(s: symbol, c: Identifier, n: number)

/**
 * Helper functions
 **************************************************************************/

.decl any_position(n: number)
any_position(n) :- token(_, _, n).

#define ZERO_OR_MORE(take_many, take_one) \
    take_many(nil, A, A) :- any_position(A). \
    take_many([x, xs], A, C) :- take_one(x, A, B), take_many(xs, B, C).

#define OPTIONAL(take_zero_or_one, take_one) \
    take_zero_or_one(nil, A, A) :- any_position(A). \
    take_zero_or_one([x], A, B) :- take_one(x, A, B).

#define INFIX(node, current_level, next_level, symbol) \
    current_level(node(e1, e2), A, C) :- \
        current_level(e1, A, B), B > A, \
        token("TOKEN_OPERATOR", symbol, B), \
        next_level(e2, B + 1, C), C > B + 1.

#define PREFIX(node, current_level, next_level, symbol) \
    current_level(node(e1), A, B) :- \
        token("TOKEN_OPERATOR", symbol, A), \
        next_level(e1, A + 1, B), B > A + 1.

#define POSTFIX(node, current_level, next_level, symbol) \
    current_level(node(e1), A, B + 1) :- \
        next_level(e1, A, B), B > A, \
        token("TOKEN_OPERATOR", symbol, B).

/**
 * Lexical structure
 *
 * Adapted from ยง3 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl type_identifier(s: Identifier, a: number, b: number)
type_identifier(t, A, A + 1) :-
    token("TOKEN_IDENTIFIER", t, A).
// TODO not var or yield

.decl identifier(s: Identifier, a: number, b: number)
identifier(t, A, A + 1) :- token("TOKEN_IDENTIFIER", t, A).

.decl identifier?(s: IdentifierOptional, a: number, b: number)
OPTIONAL(identifier?, identifier)

.decl literal(a: number, b: number)

/**
 * Types, Values and Variables
 *
 * Adapted from ยง4 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl type(s: Type, a: number, b: number)

.decl primitive_type(s: Type, a: number, b: number)

.decl numeric_type(s: Type, a: number, b: number)
numeric_type(e, A, B) :- integral_type(e, A, B).
numeric_type(e, A, B) :- floating_point_type(e, A, B).

.decl integral_type(t: Type, a: number, b: number)
integral_type($Byte,    A, A + 1) :- token("TOKEN_KEYWORD", "byte", A).
integral_type($Short,   A, A + 1) :- token("TOKEN_KEYWORD", "short", A).
integral_type($Int,     A, A + 1) :- token("TOKEN_KEYWORD", "int", A).
integral_type($Long,    A, A + 1) :- token("TOKEN_KEYWORD", "long", A).
integral_type($Char,    A, A + 1) :- token("TOKEN_KEYWORD", "char", A).

.decl floating_point_type(t: Type, a: number, b: number)
floating_point_type($Float, A, A + 1) :-
    token("TOKEN_KEYWORD", "float", A).
floating_point_type($Double, A, A + 1) :-
    token("TOKEN_KEYWORD", "double", A).

.decl reference_type(t: Type, a: number, b: number)
reference_type(t, A, B) :- class_or_interface_type(t, A, B).
reference_type(t, A, B) :- type_variable(t, A, B).
reference_type(t, A, B) :- array_type(t, A, B).

.decl class_or_interface_type(t: Type, a: number, b: number)
class_or_interface_type(t, A, B) :- class_type(t, A, B).
class_or_interface_type(t, A, B) :- interface_type(t, A, B).

.decl class_type(t: Type, a: number, b: number)

.decl interface_type(t: Type, a: number, b: number)
interface_type(t, A, B) :- class_type(t, A, B).

.decl type_variable(t: Type, a: number, b: number)

.decl array_type(t: Type, a: number, b: number)

.decl dims(e: DimensionList, a: number, b: number)
dims([x, nil], A, B) :- dim(x, A, B).
dims([x, xs],  A, B) :- dim(x, A, B), dims(xs, A, B).

.decl dim(t: Dimension, a: number, b: number)
dim($Dimension(a), A, B + 2) :-
    annotations?(a, A, B),
    token("TOKEN_BRACKET", "[", B),
    token("TOKEN_BRACKET", "]", B + 1).

.decl type_parameter(t: Type, a: number, b: number)

.decl type_parameter_modifier(t: Annotation, a: number, b: number)
type_parameter_modifier(t, A, B) :- annotation(t, A, B).

.decl type_bound(a: number, b: number)

.decl additional_bound(a: number, b: number)

.decl type_arguments(a: number, b: number)

.decl type_argument_list(a: number, b: number)

.decl type_argument(a: number, b: number)

.decl wildcard(a: number, b: number)

.decl wildcard_bounds(a: number, b: number)

/**
 * Names
 *
 * Adapted from ยง6 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl module_name(s: IdentifierList, a: number, b: number)

.decl package_name(s: IdentifierList, a: number, b: number)

.decl type_name(s: IdentifierList, a: number, b: number)
type_name([t, nil], A, B) :- type_identifier(t, A, B).
type_name([t, tail], A, C) :-
    package_or_type_name(tail, A, B),
    token("TOKEN_SEPARATOR", ".", B),
    type_identifier(t, B + 1, C).
// ... TODO: reverse?

.decl expression_name(s: IdentifierList, a: number, b: number)
expression_name([e, nil], A, A + 1) :- token("TOKEN_IDENTIFIER", e, A).
expression_name([e, tail], A, B + 2) :-
    ambiguous_name(tail, A, B),
    token("TOKEN_SEPARATOR", ".", B),
    token("TOKEN_IDENTIFIER", e, B + 1).
// ... TODO: reverse?

.decl method_name(x: Identifier, a: number, b: number)
method_name(x, A, A + 1) :- token("TOKEN_IDENTIFIER", x, A).
// ... TODO: not yield

.decl package_or_type_name(s: IdentifierList, a: number, b: number)
package_or_type_name([x, nil], A, A + 1) :- token("TOKEN_IDENTIFIER", x, A).
package_or_type_name([x, xs], A, B + 2) :-
    package_or_type_name(xs, A, B), B > A,
    token("TOKEN_SEPARATOR", ".", B),
    token("TOKEN_IDENTIFIER", x, B + 1).
// ... TODO: reverse?

.decl ambiguous_name(s: IdentifierList, a: number, b: number)
ambiguous_name([x, nil], A, A + 1) :- token("TOKEN_IDENTIFIER", x, A).
ambiguous_name([x, xs], A, A + 1) :-
    ambiguous_name(xs, A, B),
    token("TOKEN_SEPARATOR", ".", B),
    token("TOKEN_IDENTIFIER", x, B + 1).
// ... TODO: reverse?

/**
 * Packages and Modules
 *
 * Adapted from ยง7 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl compilation_unit(e: CompilationUnit, a: number, b: number)
compilation_unit(e, A, B) :- ordinary_compilation_unit(e, A, B).
compilation_unit(e, A, B) :- modular_compilation_unit(e, A, B).

.decl ordinary_compilation_unit(e: CompilationUnit, a: number, b: number)

.decl modular_compilation_unit(e: CompilationUnit, a: number, b: number)

.decl package_declaration(e: PackageDeclaration, a: number, b: number)
package_declaration($PackageDeclaration(mods, ids), A, C + 1) :-
    package_modifiers?(mods, A, B),
    token("TOKEN_KEYWORD", "package", B),
    package_declaration_identifiers(ids, B + 1, C),
    token("TOKEN_SEPARATOR", ";", C).

.decl package_declaration_identifiers(e: IdentifierList, a: number, b: number)
package_declaration_identifiers([x, nil], A, B) :- identifier(x, A, B).
package_declaration_identifiers([x, xs], A, C) :-
    identifier(x, A, B),
    token("TOKEN_SEPARATOR", ".", B),
    package_declaration_identifiers(xs, B + 1, C).

.decl package_modifier(e: Annotation, a: number, b: number)
package_modifier(e, A, B) :- annotation(e, A, B).

.decl package_modifiers?(e: AnnotationList, a: number, b: number)
ZERO_OR_MORE(package_modifiers?, package_modifier)

.decl import_declaration(s: ImportDeclaration, a: number, b: number)
import_declaration(e, A, B) :- single_type_import_declaration(e, A, B).
import_declaration(e, A, B) :- type_import_on_demand_declaration(e, A, B).
import_declaration(e, A, B) :- single_static_import_declaration(e, A, B).
import_declaration(e, A, B) :- static_import_on_demand_declaration(e, A, B).

.decl single_type_import_declaration(s: ImportDeclaration, a: number, b: number)
single_type_import_declaration($Import(syms), A, B + 1) :-
    token("TOKEN_KEYWORD", "import", A),
    type_name(syms, A + 1, B),
    token("TOKEN_SEPARATOR", ";", B).

.decl type_import_on_demand_declaration(s: ImportDeclaration, a: number, b: number)
type_import_on_demand_declaration($ImportOnDemandFrom(syms), A, B + 3) :-
    token("TOKEN_KEYWORD", "import", A),
    type_name(syms, A + 1, B),
    token("TOKEN_SEPARATOR", ".", B),
    token("TOKEN_OPERATOR",  "*", B + 1),
    token("TOKEN_SEPARATOR", ";", B + 2).

.decl single_static_import_declaration(s: ImportDeclaration, a: number, b: number)

.decl static_import_on_demand_declaration(s: ImportDeclaration, a: number, b: number)

.decl type_declaration(s: Declaration, a: number, b: number)
type_declaration(e, A, B) :- class_declaration(e, A, B).
type_declaration(e, A, B) :- interface_declaration(e, A, B).

.decl module_declaration(s: Declaration, a: number, b: number)

.decl module_directive(s: ModuleDirective, a: number, b: number)

.decl requires_modifier(s: Identifier, a: number, b: number)

/**
 * Classes
 *
 * Adapted from ยง8 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.output class_declaration
.decl class_declaration(s: Declaration, a: number, b: number)
class_declaration(e, A, B) :- normal_class_declaration(e, A, B).
class_declaration(e, A, B) :- enum_declaration(e, A, B).

.decl normal_class_declaration(s: Declaration, a: number, b: number)
normal_class_declaration($ClassDeclaration(modifiers, id, sup, declarations), A, E) :-
    class_modifiers?(modifiers, A, B),
    token("TOKEN_KEYWORD", "class", B),
    type_identifier(id, B + 1, C), C > B + 1,
    superclass?(sup, C, D),
    class_body(declarations, D, E).

.decl class_modifiers?(s: IdentifierList, a: number, b: number)
ZERO_OR_MORE(class_modifiers?, class_modifier)

.decl class_modifier(s: Identifier, a: number, b: number)
class_modifier("public", A, A + 1) :- token("TOKEN_KEYWORD", "public", A).
class_modifier("protected", A, A + 1) :- token("TOKEN_KEYWORD", "protected", A).
class_modifier("private", A, A + 1) :- token("TOKEN_KEYWORD", "private", A).
class_modifier("abstract", A, A + 1) :- token("TOKEN_KEYWORD", "abstract", A).
class_modifier("static", A, A + 1) :- token("TOKEN_KEYWORD", "static", A).
class_modifier("final", A, A + 1) :- token("TOKEN_KEYWORD", "final", A).
class_modifier("strictfp", A, A + 1) :- token("TOKEN_KEYWORD", "strictfp", A).

.decl type_parameters(s: TypeList, a: number, b: number)
type_parameters(nil, A, A) :- any_position(A).
type_parameters(l, A, B) :-
    token("TOKEN_OPERATOR", "<", A),
    type_parameter_list(l, A + 1, B),
    token("TOKEN_OPERATOR", ">", B).

.decl type_parameter_list(s: TypeList, a: number, b: number)
type_parameter_list([e, nil], A, B) :- type_parameter(e, A, B).
type_parameter_list([e, tail], A, C) :-
    type_parameter(e, A, B),
    token("TOKEN_SEPARATOR", ",", B),
    type_parameter_list(tail, B+1, C).

.decl superclass(t: Type, a: number, b: number)
superclass(t, A, B) :-
    token("TOKEN_KEYWORD", "extends", A),
    class_type(t, A + 1, B).

.decl superclass?(t: TypeOptional, a: number, b: number)
OPTIONAL(superclass?, superclass)

.decl superinterfaces(t: Type, a: number, b: number)

// TODO InterfaceTypeList

.decl class_body(s: DeclarationList, a: number, b: number)
class_body(declarations, A, B + 1) :-
    token("TOKEN_BRACKET", "{", A),
    class_body_declarations?(declarations, A + 1, B),
    token("TOKEN_BRACKET", "}", B).

.decl class_body_declarations?(d: DeclarationList, a: number, b: number)
ZERO_OR_MORE(class_body_declarations?, class_body_declaration)

.decl class_body_declaration(d: Declaration, a: number, b: number)
class_body_declaration(e, A, B) :- class_member_declaration(e, A, B).
class_body_declaration(e, A, B) :- instance_initializer(e, A, B).
// ... TODO

.decl class_member_declaration(s: Declaration, a: number, b: number)
class_member_declaration(e, A, B) :- field_declaration(e, A, B).
class_member_declaration(e, A, B) :- method_declaration(e, A, B).
class_member_declaration(e, A, B) :- class_declaration(e, A, B).
class_member_declaration(e, A, B) :- interface_declaration(e, A, B).
class_member_declaration($EmptyDeclaration, A, A + 1)
    :- token("TOKEN_SEPARATOR", ";", A).

.decl field_declaration(s: Declaration, a: number, b: number)

.decl field_modifier(s: Identifier, a: number, b: number)

.decl variable_declarator_list(s: VariableDeclarationList, a: number, b: number)

.decl variable_declarator(s: VariableDeclaration, a: number, b: number)

// TODO VariableDeclaratorId

.decl variable_initializer(s: Expression, a: number, b: number)
variable_initializer(e, A, B) :- expression(e, A, B).
variable_initializer(e, A, B) :- array_initializer(e, A, B).

.decl unann_type(t: Type, a: number, b: number)
unann_type(e, A, B) :- unann_primitive_type(e, A, B).
unann_type(e, A, B) :- unann_reference_type(e, A, B).

.decl unann_primitive_type(t: Type, a: number, b: number)
unann_primitive_type($Boolean, A, A + 1) :-
    token("TOKEN_KEYWORD", "boolean", A).
unann_primitive_type(e, A, B) :- numeric_type(e, A, B).

.decl unann_reference_type(t: Type, a: number, b: number)
unann_reference_type(t, A, B) :- unann_class_or_interface_type(t, A, B).
unann_reference_type(t, A, B) :- unann_type_variable(t, A, B).
unann_reference_type(t, A, B) :- unann_array_type(t, A, B).

.decl unann_class_or_interface_type(t: Type, a: number, b: number)
unann_class_or_interface_type(t, A, B) :- unann_class_type(t, A, B).
unann_class_or_interface_type(t, A, B) :- unann_interface_type(t, A, B).

.decl unann_class_type(t: Type, a: number, b: number)

.decl unann_interface_type(t: Type, a: number, b: number)

.decl unann_type_variable(t: Type, a: number, b: number)

.decl unann_array_type(t: Type, a: number, b: number)

.decl method_declaration(s: Declaration, a: number, b: number)
method_declaration($MethodDeclaration(modifiers, header, body), A, D) :-
    method_modifiers?(modifiers, A, B),
    method_header(header, B, C),
    method_body(body, C, D).

.decl method_modifiers?(s: IdentifierList, a: number, b: number)
ZERO_OR_MORE(method_modifiers?, method_modifier)

.decl method_modifier(s: Identifier, a: number, b: number)
method_modifier("public", A, A + 1) :- token("TOKEN_KEYWORD", "public", A).
method_modifier("protected", A, A + 1) :- token("TOKEN_KEYWORD", "protected", A).
method_modifier("private", A, A + 1) :- token("TOKEN_KEYWORD", "private", A).
method_modifier("abstract", A, A + 1) :- token("TOKEN_KEYWORD", "abstract", A).
method_modifier("static", A, A + 1) :- token("TOKEN_KEYWORD", "static", A).
method_modifier("final", A, A + 1) :- token("TOKEN_KEYWORD", "final", A).
method_modifier("synchronized", A, A + 1) :- token("TOKEN_KEYWORD", "synchronized", A).
method_modifier("native", A, A + 1) :- token("TOKEN_KEYWORD", "native", A).
method_modifier("strictfp", A, A + 1) :- token("TOKEN_KEYWORD", "strictfp", A).

.decl method_header(s: MethodHeader, a: number, b: number)

.decl result(t: Type, a: number, b: number)
result(t, A, B) :- unann_type(t, A, B).
result($Void, A, A + 1) :- token("TOKEN_KEYWORD", "void", A).

// TODO MethodDeclarator

// TODO ReceiverParameter

// TODO FormalParameterList

// TODO FormalParameter

// TODO VariableArityParameter

// TODO VariableModifier

// TODO Throws

// TODO ExceptionTypeList

// TODO ExceptionType

.decl method_body(s: Statement, a: number, b: number)
method_body(e, A, B + 1) :-
    block(e, A, B),
    token("TOKEN_SEPARATOR", ";", B).

.decl instance_initializer(s: Declaration, a: number, b: number)
instance_initializer($InstanceInitializerDeclaration(e), A, B) :- block(e, A, B).

.decl static_initializer(s: Statement, a: number, b: number)
static_initializer(e, A, B) :-
    token("TOKEN_KEYWORD", "static", A),
    block(e, A + 1, B).
// ... TODO - looses static information

// TODO ConstructorDeclaration

// TODO ConstructorModifier

// TODO ConstructorDeclarator

.decl simple_type_name(s: symbol, l: number, n: number)
simple_type_name(e, A, B) :- type_identifier(e, A, B).

// TODO ConstructorBody

// TODO ExplicitConstructorInvocation

.decl enum_declaration(s: Declaration, a: number, b: number)

// TODO EnumBody

// TODO EnumConstantList

// TODO EnumConstant

// TODO EnumConstantModifier

// TODO EnumBodyDeclaration

/**
 * Interfaces
 *
 * Adapted from ยง9 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl interface_declaration(s: Declaration, a: number, b: number)
interface_declaration(e, A, B) :- normal_interface_declaration(e, A, B).
interface_declaration(e, A, B) :- annotation_type_declaration(e, A, B).

.decl normal_interface_declaration(s: Declaration, a: number, b: number)

.decl annotation_type_declaration(s: Declaration, a: number, b: number)

.decl annotation_type_body(a: number, b: number)

.decl annotation_type_member_declaration(a: number, b: number)

.decl annotation_type_element_declaration(a: number, b: number)

.decl annotation_type_element_modifier(a: number, b: number)

.decl default_value(a: number, b: number)

.decl annotation(e: Annotation, a: number, b: number)
annotation(e, A, B) :- normal_annotation(e, A, B).

.decl annotations?(e: AnnotationList, a: number, b: number)
ZERO_OR_MORE(annotations?, annotation)

.decl normal_annotation(e: Annotation, a: number, b: number)
normal_annotation([name, nil], A, B + 2) :-
    token("TOKEN_SEPARATOR", "@", A),
    type_name(name, A + 1, B),
    token("TOKEN_BRACKET", "(", B),
    token("TOKEN_BRACKET", ")", B + 1).
normal_annotation([name, pairs], A, C + 1) :-
    token("TOKEN_SEPARATOR", "@", A),
    type_name(name, A + 1, B),
    token("TOKEN_BRACKET", "(", B),
    element_value_pair_list(pairs, B + 1, C),
    token("TOKEN_BRACKET", ")", C).

.decl element_value_pair_list(e: ElementValuePairList, a: number, b: number)

.decl element_value_pair(e: ElementValuePair, a: number, b: number)

.decl element_value(e: ElementValue, a: number, b: number)

/**
 * Arrays
 *
 * Adapted from ยง10 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl array_initializer(e: Expression, a: number, b: number)
array_initializer($ArrayInitializer(e), A, B + 1) :- 
    token("TOKEN_BRACKET", "{", A),
    variable_initializer_list(e, A + 1, B),
    token("TOKEN_BRACKET", "}", B).
array_initializer($ArrayInitializer(e), A, B + 2) :- 
    token("TOKEN_BRACKET", "{", A),
    variable_initializer_list(e, A + 1, B),
    token("TOKEN_SEPARATOR", ",", B),
    token("TOKEN_BRACKET", "}", B + 1).

.decl variable_initializer_list(s: ExpressionList, a: number, b: number)
variable_initializer_list(nil, A, A) :- any_position(A).
variable_initializer_list([e, tail], A, C) :-
    variable_initializer(e, A, B), B > A,
    token("TOKEN_SEPARATOR", ",", B),
    variable_initializer_list(tail, B, C).
    // TODO, logic here is broken

/**
 * Blocks and Statements
 *
 * Adapted from ยง14 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl block(s: Statement, a: number, b: number)
block($Block(s), A, B + 1) :-
    token("TOKEN_BRACKET", "{", A),
    block_statements?(s, A + 1, B),
    token("TOKEN_BRACKET", "}", B).

.decl block_statements?(s: StatementList, a: number, b: number)
ZERO_OR_MORE(block_statements?, block_statement)

.decl block_statement(s: Statement, a: number, b: number)
block_statement(e, A, B) :- statement(e, A, B).

.decl local_variable_declaration_statement(s: Statement, a: number, b: number)
local_variable_declaration_statement(e, A, B + 1) :-
    local_variable_declaration(e, A, B),
    token("TOKEN_SEPARATOR", ";", B).

.decl local_variable_declaration(s: Statement, a: number, b: number)

.decl local_variable_type(t: Type, a: number, b: number)
local_variable_type(t, A, B) :- unann_type(t, A, B).

.decl statement(s: Statement, a: number, b: number)
statement(e, A, B) :- statement_without_trailing_substatement(e, A, B).
statement(e, A, B) :- labeled_statement(e, A, B).
statement(e, A, B) :- if_then_statement(e, A, B).
statement(e, A, B) :- if_then_else_statement(e, A, B).
statement(e, A, B) :- while_statement(e, A, B).
statement(e, A, B) :- for_statement(e, A, B).

.decl statement_no_short_if(s: Statement, a: number, b: number)
statement_no_short_if(e, A, B) :- statement_without_trailing_substatement(e, A, B).
statement_no_short_if(e, A, B) :- labeled_statement_no_short_if(e, A, B).
statement_no_short_if(e, A, B) :- if_then_else_statement_no_short_if(e, A, B).
statement_no_short_if(e, A, B) :- while_statement_no_short_if(e, A, B).
statement_no_short_if(e, A, B) :- for_statement_no_short_if(e, A, B).

.decl statement_without_trailing_substatement(s: Statement, a: number, b: number)
statement_without_trailing_substatement(e, A, B) :- block(e, A, B).
statement_without_trailing_substatement(e, A, B) :- empty_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- expression_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- assert_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- switch_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- do_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- break_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- continue_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- return_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- synchronized_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- throw_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- try_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- yield_statement(e, A, B).

.decl empty_statement(s: Statement, a: number, b: number)
empty_statement($Empty, A, A + 1) :-
    token("TOKEN_SEPARATOR", ";", A).

.decl labeled_statement(s: Statement, a: number, b: number)
labeled_statement($Label(id, st), A, B) :-
    token("TOKEN_IDENTIFIER", id, A),
    token("TOKEN_SEPARATOR", ":", A + 1),
    statement(st, A + 2, B).

.decl labeled_statement_no_short_if(s: Statement, a: number, b: number)
labeled_statement_no_short_if($Label(id, st), A, B) :-
    token("TOKEN_IDENTIFIER", id, A),
    token("TOKEN_SEPARATOR", ":", A + 1),
    statement_no_short_if(st, A + 2, B).

.decl expression_statement(e: Statement, a: number, b: number)
expression_statement($ExpressionStatement(e), A, B + 1) :-
    statement_expression(e, A, B),
    token("TOKEN_SEPARATOR", ";", B).

.decl statement_expression(e: Expression, a: number, b: number)
statement_expression(e, A, B) :- assignment(e, A, B).
statement_expression(e, A, B) :- pre_increment_expression(e, A, B).
statement_expression(e, A, B) :- pre_decrement_expression(e, A, B).
statement_expression(e, A, B) :- post_increment_expression(e, A, B).
statement_expression(e, A, B) :- post_decrement_expression(e, A, B).
statement_expression(e, A, B) :- method_invocation(e, A, B).
statement_expression(e, A, B) :- class_instance_creation_expression(e, A, B).

.decl if_then_statement(s: Statement, a: number, b: number)
if_then_statement($IfThen(e, s), A, C) :-
    token("TOKEN_KEYWORD", "if", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e, A + 2, B), B > A + 2,
    token("TOKEN_BRACKET", ")", B),
    statement(s, B + 1, C), C > B + 1.

.decl if_then_else_statement(s: Statement, a: number, b: number)
if_then_else_statement($IfThenElse(e, s1, s2), A, D) :-
    token("TOKEN_KEYWORD", "if", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e, A + 2, B), B > A + 2,
    token("TOKEN_BRACKET", ")", B),
    statement_no_short_if(s1, B + 1, C), C > B + 1,
    token("TOKEN_KEYWORD", "else", C),
    statement(s2, C + 1, D), D > C + 1.

.decl if_then_else_statement_no_short_if(s: Statement, a: number, b: number)

.decl assert_statement(s: Statement, a: number, b: number)
assert_statement($Assert(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "assert", A),
    expression(e, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ";", B).
assert_statement($AssertDetailed(e1, e2), A, C + 1) :-
    token("TOKEN_KEYWORD", "assert", A),
    expression(e1, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ":", B),
    expression(e2, B + 1, C), C > B + 1,
    token("TOKEN_SEPARATOR", ";", C).

.decl switch_statement(s: Statement, a: number, b: number)
switch_statement($Switch(e, rules), A, C) :-
    token("TOKEN_KEYWORD", "switch", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e, A + 2, B), B > A + 2,
    token("TOKEN_BRACKET", ")", B),
    switch_block(rules, B + 1, C), C > B + 1.

.decl switch_block(s: SwitchRuleList, a: number, b: number)
switch_block([rule, rules], A, C + 1) :-
    token("TOKEN_BRACKET", "{", A),
    switch_rule(rule, A + 1, B),
    switch_rules?(rules, B, C),
    token("TOKEN_BRACKET", "}", C).

.decl switch_rules?(e: SwitchRuleList, a: number, b: number)
ZERO_OR_MORE(switch_rules?, switch_rule)

.decl switch_rule(e: SwitchRule, a: number, b: number)
switch_rule($SwitchRuleExpression(label, expr), A, C + 1) :-
    switch_label(label, A, B),
    token("TOKEN_SEPARATOR", "->", B),
    expression(expr, B + 1, C),
    token("TOKEN_SEPARATOR", ";", C).
switch_rule($SwitchRuleBlock(label, stmt), A, C) :-
    switch_label(label, A, B),
    token("TOKEN_SEPARATOR", "->", B),
    block(stmt, B + 1, C).
switch_rule($SwitchRuleBlock(label, stmt), A, C) :-
    switch_label(label, A, B),
    token("TOKEN_SEPARATOR", "->", B),
    throw_statement(stmt, B + 1, C).

.decl switch_block_statement_group(a: number, b: number)

.decl switch_label(s: SwitchLabel, a: number, b: number)
switch_label($SwitchDefault, A, A + 1) :-
    token("TOKEN_KEYWORD", "default", A).
switch_label($SwitchCase(exprs), A, B) :-
    token("TOKEN_KEYWORD", "case", A),
    case_constants(exprs, A + 1, B).

.decl case_constants(e: ExpressionList, a: number, b: number)
case_constants([x, nil], A, B) :- case_constant(x, A, B).
case_constants([x, xs], A, C) :-
    case_constant(x, A, B),
    token("TOKEN_SEPARATOR", ",", B),
    case_constants(xs, B + 1, C).

.decl case_constant(e: Expression, a: number, b: number)
case_constant(e, A, B) :- conditional_expression(e, A, B).

.decl while_statement(s: Statement, a: number, b: number)
while_statement($While(cond, do), A, C) :-
    token("TOKEN_KEYWORD", "while", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(cond, A + 2, B), B > A + 2,
    token("TOKEN_BRACKET", ")", B),
    statement(do, B + 1, C), C > B + 1.

.decl while_statement_no_short_if(s: Statement, a: number, b: number)

.decl do_statement(s: Statement, a: number, b: number)
do_statement($Do(cond, do), A, C + 2) :-
    token("TOKEN_KEYWORD", "do", A),
    statement(do, A + 1, B),  B > A + 1,
    token("TOKEN_KEYWORD", "while", B),
    token("TOKEN_BRACKET", "(", B + 1),
    expression(cond, B + 2, C), C > B + 2,
    token("TOKEN_BRACKET", ")", C),
    token("TOKEN_SEPARATOR", ";", C + 1).

.decl for_statement(s: Statement, a: number, b: number)

.decl for_statement_no_short_if(s: Statement, a: number, b: number)

.decl basic_for_statement(s: Statement, a: number, b: number)

.decl basic_for_statement_no_short_if(s: Statement, a: number, b: number)

.decl for_init(s: Statement, a: number, b: number)
for_init(e, A, B) :- statement_expression_list(e, A, B).
for_init(e, A, B) :- local_variable_declaration(e, A, B).

.decl for_update(s: Statement, a: number, b: number)
for_update(e, A, B) :- statement_expression_list(e, A, B).

.decl statement_expression_list(s: Statement, a: number, b: number)

.decl enhanced_for_statement(s: Statement, a: number, b: number)

.decl enhanced_for_statement_no_short_if(s: Statement, a: number, b: number)

.decl break_statement(s: Statement, a: number, b: number)
break_statement($Break(id), A, B + 1) :-
    token("TOKEN_KEYWORD", "break", A),
    identifier?(id, A + 1, B),
    token("TOKEN_SEPARATOR", ";", B).

.decl yield_statement(s: Statement, a: number, b: number)
yield_statement($Yield(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "yield", A),
    expression(e, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ";", B).

.decl continue_statement(s: Statement, a: number, b: number)
continue_statement($Continue(id), A, B + 1) :-
    token("TOKEN_KEYWORD", "continue", A),
    identifier?(id, A + 1, B),
    token("TOKEN_SEPARATOR", ";", B).

.decl return_statement(s: Statement, a: number, b: number)
return_statement($Return(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "return", A),
    expression?(e, A + 1, B),
    token("TOKEN_SEPARATOR", ";", B).

.decl throw_statement(s: Statement, a: number, b: number)
throw_statement($Throw(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "throw", A),
    expression(e, A + 1, B),
    token("TOKEN_SEPARATOR", ";", B).

.decl synchronized_statement(s: Statement, a: number, b: number)
synchronized_statement($Synchronized(e, s), A, C) :-
    token("TOKEN_KEYWORD", "synchronized", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e, A + 2, B),
    token("TOKEN_BRACKET", ")", B),
    block(s, B, C).

.decl try_statement(s: Statement, a: number, b: number)

// TODO Catches

// TODO CatchClause

// TODO CatchFormalParameter

// TODO CatchType

// TODO Finally

// TODO TryWithResourcesStatement

// TODO ResourceSpecification

// TODO ResourceList

// TODO Resource

/**
 * Expressions
 *
 * Adapted from ยง15 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl primary(e: Expression, a: number, b: number)
primary(e, A, B) :- primary_no_new_array(e, A, B).
primary(e, A, B) :- array_creation_expression(e, A, B).

.decl primary_no_new_array(e: Expression, a: number, b: number)
primary_no_new_array($Literal, A, B) :- literal(A, B).
primary_no_new_array(e, A, B) :- class_literal(e, A, B).
primary_no_new_array($This, A, A + 1) :- token("TOKEN_KEYWORD", "this", A).
primary_no_new_array(e, A, B + 1) :-
    token("TOKEN_BRACKET", "(", A),
    expression(e, A + 1, B),
    token("TOKEN_BRACKET", ")", B).
primary_no_new_array(e, A, B) :- class_instance_creation_expression(e, A, B).
primary_no_new_array(e, A, B) :- field_access(e, A, B).
primary_no_new_array(e, A, B) :- array_access(e, A, B).
primary_no_new_array(e, A, B) :- method_invocation(e, A, B).
primary_no_new_array(e, A, B) :- method_reference(e, A, B).

.decl class_literal(e: Expression, a: number, b: number)

.decl class_instance_creation_expression(e: Expression, a: number, b: number)

.decl unqualified_class_instance_creation_expression(e: Expression, a: number, b: number)

.decl class_or_interface_type_to_instantiate(e: Expression, a: number, b: number)

.decl type_arguments_or_diamond(e: Expression, a: number, b: number)

.decl field_access(e: Expression, a: number, b: number)

.decl array_access(e: Expression, a: number, b: number)

.decl method_invocation(e: Expression, a: number, b: number)
method_invocation(e, A, B) :- method_invocation_with_method_name(e, A, B).

.decl method_invocation_with_method_name(e: Expression, a: number, b: number)
method_invocation_with_method_name($MethodInvocation(id, e), A, C + 1) :-
    method_name(id, A, B),
    token("TOKEN_BRACKET", "(", B),
    argument_list?(e, B + 1, C),
    token("TOKEN_BRACKET", ")", C).

.decl argument_list?(e: ExpressionList, a: number, b: number)
argument_list?(nil, A, A) :- any_position(A).
argument_list?(e, A, B) :- argument_list(e, A, B).

.decl argument_list(e: ExpressionList, a: number, b: number)
argument_list([x, nil], A, B) :- expression(x, A, B).
argument_list([x, xs], A, C) :-
    expression(x, A, B),
    token("TOKEN_SEPARATOR", ",", B),
    argument_list(xs, B + 1, C).

.decl method_reference(e: Expression, a: number, b: number)

.decl array_creation_expression(e: Expression, a: number, b: number)

.decl dim_exprs(a: number, b: number)
.decl dim_expr(a: number, b: number)

.decl expression(e: Expression, a: number, b: number)
expression(e, A, B) :- conditional_expression(e, A, B).
expression(e, A, B) :- lambda_expression(e, A, B).

.decl expression?(e: ExpressionOptional, a: number, b: number)
OPTIONAL(expression?, expression)

.decl lambda_expression(e: Expression, a: number, b: number)
lambda_expression($Lambda(params, body), A, C) :-
    lambda_parameters(params, A, B),
    token("TOKEN_SEPARATOR", "->", B),
    lambda_body(body, B + 1, C).

.decl lambda_parameters(p: LambdaParameters, a: number, b: number)

.decl lambda_parameter_list(a: number, b: number)

.decl lambda_parameter(a: number, b: number)

.decl lambda_parameter_type(t: Type, a: number, b: number)
lambda_parameter_type(t, A, B) :- unann_type(t, A, B).
lambda_parameter_type($Var, A, A + 1) :- token("TOKEN_KEYWORD", "var", A).

.decl lambda_body(e: LambdaBody, a: number, b: number)
lambda_body($LambdaBodyExpression(e), A, B) :- expression(e, A, B).
lambda_body($LambdaBodyBlock(e), A, B) :- block(e, A, B).

.decl assignment_expression(e: Expression, a: number, b: number)
assignment_expression(e, A, B) :- conditional_expression(e, A, B).
assignment_expression(e, A, B) :- assignment(e, A, B).

.decl assignment(e: Expression, a: number, b: number)
assignment($Assign(e1, s, e2), A, D) :-
    left_hand_side(e1, A, B),
    assignment_operator(s, B, C),
    expression(e2, C, D).

.decl left_hand_side(e: Expression, a: number, b: number)

.decl assignment_operator(s: symbol, a: number, b: number)
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "==".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "*=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "/=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "%=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "+=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "-=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "<<=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = ">>=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = ">>>=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "&=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "^=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "|=".

.decl conditional_expression(e: Expression, a: number, b: number)
conditional_expression(e, A, B) :- conditional_or_expression(e, A, B).
conditional_expression(e, A, D) :-
    conditional_or_expression(e, A, B), B > A,
    token("TOKEN_SEPARATOR", "?", B),
    expression(e, B + 1, C), C > B + 1,
    token("TOKEN_SEPARATOR", ":", C),
    conditional_expression(e, C + 1, D), D > C + 1.
conditional_expression(e, A, D) :-
    conditional_or_expression(e, A, B), B > A,
    token("TOKEN_SEPARATOR", "?", B),
    expression(e, B + 1, C), C > B + 1,
    token("TOKEN_SEPARATOR", ":", C),
    lambda_expression(e, C + 1, D), D > C + 1.

.decl conditional_or_expression(e: Expression, a: number, b: number)
conditional_or_expression(e, A, B) :- conditional_and_expression(e, A, B).
INFIX($Or, conditional_or_expression, conditional_and_expression, "||")

.decl conditional_and_expression(e: Expression, a: number, b: number)
conditional_and_expression(e, A, B) :- inclusive_or_expression(e, A, B).
INFIX($And, conditional_and_expression, inclusive_or_expression, "&&")

.decl inclusive_or_expression(e: Expression, a: number, b: number)
inclusive_or_expression(e, A, B) :- exclusive_or_expression(e, A, B).
INFIX($BitwiseInclOr, inclusive_or_expression, exclusive_or_expression, "|")

.decl exclusive_or_expression(e: Expression, a: number, b: number)
exclusive_or_expression(e, A, B) :- and_expression(e, A, B).
INFIX($BitwiseExclOr, exclusive_or_expression, and_expression, "^")

.decl and_expression(e: Expression, a: number, b: number)
and_expression(e, A, B) :- equality_expression(e, A, B).
INFIX($BitwiseAnd, and_expression, equality_expression, "&")

.decl equality_expression(e: Expression, a: number, b: number)
equality_expression(e, A, B) :-       relational_expression(e, A, B).
INFIX($Equal,    equality_expression, relational_expression, "==")
INFIX($NotEqual, equality_expression, relational_expression, "!=")

.decl relational_expression(e: Expression, a: number, b: number)
relational_expression(e, A, B) :- shift_expression(e, A, B).

.decl shift_expression(e: Expression, a: number, b: number)
shift_expression(e, A, B) :- additive_expression(e, A, B).
INFIX($ShiftLeft,          shift_expression, additive_expression, "<<")
INFIX($ShiftRight,         shift_expression, additive_expression, ">>")
INFIX($ShiftRightUnsigned, shift_expression, additive_expression, ">>>")

.decl additive_expression(e: Expression, a: number, b: number)
additive_expression(e, A, B) :- multiplicative_expression(e, A, B).
INFIX($Add, additive_expression, multiplicative_expression, "+")
INFIX($Sub, additive_expression, multiplicative_expression, "-")

.decl multiplicative_expression(e: Expression, a: number, b: number)
multiplicative_expression(e, A, B) :- unary_expression(e, A, B).
INFIX($Mul, multiplicative_expression, unary_expression, "*")
INFIX($Div, multiplicative_expression, unary_expression, "/")
INFIX($Mod, multiplicative_expression, unary_expression, "%")

.decl unary_expression(e: Expression, a: number, b: number)
unary_expression(e, A, B) :- postfix_expression(e, A, B).
unary_expression(e, A, B) :- pre_increment_expression(e, A, B).
unary_expression(e, A, B) :- pre_decrement_expression(e, A, B).

.decl pre_increment_expression(e: Expression, a: number, b: number)
PREFIX($PreIncrement, pre_increment_expression, unary_expression, "++")

.decl pre_decrement_expression(e: Expression, a: number, b: number)
PREFIX($PreDecrement, pre_decrement_expression, unary_expression, "--")

.decl unary_expression_not_plus_minus(e: Expression, a: number, b: number)
unary_expression_not_plus_minus(e, A, B) :- postfix_expression(e, A, B).
PREFIX($BitwiseNot, unary_expression_not_plus_minus, unary_expression, "~")
PREFIX($Not, unary_expression_not_plus_minus, unary_expression, "!")

.decl postfix_expression(e: Expression, a: number, b: number)
postfix_expression(e, A, B) :- post_increment_expression(e, A, B).
postfix_expression(e, A, B) :- post_decrement_expression(e, A, B).
postfix_expression($Identifier(id), A, A + 1) :- token("TOKEN_IDENTIFIER", id, A).
postfix_expression($Number(to_number(n)), A, A + 1) :- token("TOKEN_NUMBER", n, A).

.decl post_increment_expression(e: Expression, a: number, b: number)
POSTFIX($PostIncrement, post_increment_expression, postfix_expression, "++")
.decl post_decrement_expression(e: Expression, a: number, b: number)
POSTFIX($PostDecrement, post_decrement_expression, postfix_expression, "--")

.decl cast_expression(e: Expression, a: number, b: number)

.decl switch_expression(e: Expression, a: number, b: number)
switch_expression($SwitchExpr(e1, rules), A, C) :-
    token("TOKEN_KEYWORD", "switch", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e1, A + 2, B),
    token("TOKEN_BRACKET", ")", B),
    switch_block(rules, B + 1, C).

.decl constant_expression(e: Expression, a: number, b: number)
constant_expression(e, A, B) :- expression(e, A, B).

/**
 * Root
 **************************************************************************/

.decl root(s: Statement)
root(s) :-
    statement(s, 1, N),
    token("TOKEN_EOF", _, N+1).

.output expression
.output return_statement
.output statement
.output class_modifiers?
.output type_identifier
.output class_body
.output continue_statement
.output method_invocation
.output normal_class_declaration
.output argument_list?
