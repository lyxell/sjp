.type Expression = Number {}
                 | Identifier {}
                 | Eq {e_1 : Expression, e_2 :Expression}
                 | Add {e_1 : Expression, e_2 : Expression}
                 | Sub {e_1 : Expression, e_2 : Expression}
                 | Assign {e_1 : Expression, e_2 : Expression}
                 | LessThan {e_1 : Expression, e_2 : Expression}

.type Statement = If { cond : Expression, then: Statement }
                | While { cond : Expression, then: Statement }
                | Block { s: StatementList }
                | Return { e: Expression }
                | Empty {}

.type StatementList = [
    head : Statement,
    tail : StatementList
]

.decl token(s: symbol, n: number)
.decl statement(s: Statement, n: number, l: number)
.decl one_or_more_statements(s: StatementList, n: number, l: number)
.decl expr(e: Expression, n: number, l: number)
.decl expr1(e: Expression, n: number, l: number)
.decl bin_op(e1: Expression, e2: Expression, a: number, b: number, t: symbol)
.decl par_expr(e: Expression, n: number, l: number)

.input token

/**
 * Blocks/statements
 */

one_or_more_statements([e, nil], A, B) :-
    statement(e, A, B).

one_or_more_statements([e, tail], A, C) :-
    statement(e, A, B), B >= A,
    one_or_more_statements(tail, B + 1, C), C >= B + 1.

// empty block statement
statement($Block(nil), A, A + 1) :-
    token("TOKEN_LEFT_CURLY", A),
    token("TOKEN_RIGHT_CURLY", A + 1).

// block statement
statement($Block(s), A, B + 1) :-
    token("TOKEN_LEFT_CURLY", A),
    one_or_more_statements(s, A + 1, B), B >= A + 1,
    token("TOKEN_RIGHT_CURLY", B + 1).

// if statement
statement($If(cond, then), A, C) :-
    token("TOKEN_IF", A),
    par_expr(cond, A + 1, B),   B >= A + 1,
    statement(then, B + 1, C),  C >= B + 1.

// while statement
statement($While(cond, do), A, C) :-
    token("TOKEN_WHILE", A),
    par_expr(cond, A + 1, B), B >= A + 1,
    statement(do, B + 1, C),  C >= B + 1.

// return statement
statement($Return(e), A, B) :-
    token("TOKEN_RETURN", A),
    expr(e, A + 1, B), B >= A + 1.

/**
 * Expressions
 */

// parenthesized expression
par_expr(e, A, B + 1) :-
    token("TOKEN_LEFT_PAREN",  A),
    expr(e, A + 1, B), B >= A + 1,
    token("TOKEN_RIGHT_PAREN", B + 1).

bin_op(e1, e2, A, C, T) :-
    expr(e1, A, B), B >= A,
    token(T, B + 1),
    expr1(e2, B + 2, C), C >= B + 2.
expr($Eq(e1, e2), A, B) :- bin_op(e1, e2, A, B, "TOKEN_EQUALS").
expr($Add(e1, e2), A, B) :- bin_op(e1, e2, A, B, "TOKEN_PLUS").
expr($Sub(e1, e2), A, B) :- bin_op(e1, e2, A, B, "TOKEN_MINUS").
expr($LessThan(e1, e2), A, B) :- bin_op(e1, e2, A, B, "TOKEN_LESS_THAN").

expr(e, A, B) :- expr1(e, A, B).

// identifier
expr1($Identifier(), A, A) :-
    token("TOKEN_IDENTIFIER", A).

// number
expr1($Number(), A, A) :-
    token("TOKEN_NUMBER", A).

.output par_expr
.output statement
.output expr
