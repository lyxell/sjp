/**
 * MIT License
 *
 * Copyright (c) 2021 Anton Lyxell
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Types
 **************************************************************************/

/* Identifiers */

.type Identifier <: symbol
.type IdentifierList = [head: Identifier, tail: IdentifierList]
.type IdentifierOptional = [id: Identifier]

/* Compilation unit */

.type CompilationUnit = OrdinaryCompilationUnit {pkgs: PackageDeclaration,
                                                 imps: ImportDeclarationList,
                                                 decls: DeclarationList}
                      | ModularCompilationUnit  {}

/* Variable declarations */

.type VariableDeclarator = VariableDeclarator {decl: VariableDeclaratorId,
                                               init: ExprOptional}
.type VariableDeclaratorId = VariableDeclaratorId       {id: Identifier}
                           | VariableDeclaratorArray    {id: Identifier,
                                                         dims: DimensionList}
.type Dimension = Dimension {annotations: AnnotationList}
.type DimensionList = [key: Dimension, value: DimensionList]
.type VariableDeclaratorList = [
    key: VariableDeclarator,
    value: VariableDeclaratorList
]

/* Packages and modules */

.type PackageDeclaration = PackageDeclaration {modifiers: ModifierList,
                                               ids: IdentifierList}

.type ModuleDirective = ModuleDirective {}

.type ImportDeclaration = Import                {ids: IdentifierList}
                        | ImportOnDemandFrom    {ids: IdentifierList}

.type ImportDeclarationList = [
    key: ImportDeclaration,
    value: ImportDeclarationList
]

/**
 * Annotations
 */

.type ElementValue = ElementValueExpr               {e: Expr}
                   | ElementValueAnnotation         {a: Annotation}
                   | ElementValueArrayInitializer   {e: ElementValueList}

.type ElementValueList = [
    head: ElementValue,
    tail: ElementValueList
]

.type ElementValuePair = ElementValuePair {key: Identifier,
                                           value: ElementValue}

.type ElementValuePairList = [
    head: ElementValuePair,
    tail: ElementValuePairList
]

.type Annotation = Annotation {name: IdentifierList,
                               pairs: ElementValuePairList}

.type AnnotationList = [
    name: Annotation,
    pairs: AnnotationList
]

/**
 * Modifiers
 */

.type Modifier = Public {}
               | Private {}
               | Protected {}
               | Static {}
               | Native {}
               | AnnotationModifier {annotation: Annotation}
               | Synchronized {}
               | Transient {}
               | Volatile {}
               | Abstract {}
               | Strictfp {}
               | Final {}

.type ModifierList = [
    key: Modifier,
    value: ModifierList
]

/* Expressions */

.type Expr = Add                    {e1: Expr, e2: Expr}
           | And                    {e1: Expr, e2: Expr}
           | ArrayInitializer       {e: ExprList}
           | ArrayCreation          {t: Type, dim_exprs: ExprList, dims: DimensionList}
           | ArrayCreationWithInitializer {t:Type, dims: DimensionList, init: Expr}
           | Assign                 {e1: LeftHandSide, s: symbol, e2: Expr}
           | BitwiseAnd             {e1: Expr, e2: Expr}
           | BitwiseExclOr          {e1: Expr, e2: Expr}
           | BitwiseInclOr          {e1: Expr, e2: Expr}
           | BitwiseNot             {e: Expr}
           | Cast                   {t: Type, bounds: TypeList, e: Expr}
           | Div                    {e1: Expr, e2: Expr}
           | DimensionExpr          {a: AnnotationList, e: Expr}
           | Equal                  {e1: Expr, e2: Expr}
           | Identifier             {id: Identifier}
           | Lambda                 {params: LambdaParameters, body: LambdaBody}
           | LessThan               {e1: Expr, e2: Expr}
           | Literal                {}
           | MethodInvocation       {id: Identifier, e: ExprList}
           | Mod                    {e1: Expr, e2: Expr}
           | Mul                    {e1: Expr, e2: Expr}
           | Not                    {e: Expr}
           | NotEqual               {e1: Expr, e2: Expr}
           | Number                 {n: number}
           | Or                     {e1: Expr, e2: Expr}
           | PostDecrement          {e: Expr}
           | PostIncrement          {e: Expr}
           | PreDecrement           {e: Expr}
           | PreIncrement           {e: Expr}
           | ShiftLeft              {e1: Expr, e2: Expr}
           | ShiftRight             {e1: Expr, e2: Expr}
           | ShiftRightUnsigned     {e1: Expr, e2: Expr}
           | Sub                    {e1: Expr, e2: Expr}
           | SwitchExpr             {e: Expr, s: SwitchRuleList}
           | ArrayAccessIdentifier  {id: IdentifierList, e: Expr}
           | ArrayAccessExpr        {e1: Expr, e2: Expr}
           | This                   {}

.type ExprOptional = [
    expr: Expr
]

.type ExprList = [
    head: Expr,
    tail: ExprList
]

.type LambdaParameter =
      LambdaParameter {m: ModifierList, t: Type, decl: VariableDeclaratorId}
    | LambdaParameterVariableArity {m: VariableArityParameter}

.type LambdaParameterList = [
    head: LambdaParameter,
    tail: LambdaParameterList
]

.type LambdaBody = LambdaBodyExpr   {e: Expr}
                 | LambdaBodyBlock  {e: Statement}

.type LambdaParameters = LambdaParametersIdentifier {id: Identifier}
                       | LambdaParametersIdentifierList {ids: IdentifierList}
                       | LambdaParametersLambdaParameterList {params: LambdaParameterList}

.type LeftHandSide = LeftHandSideName { e: IdentifierList }
                   | LeftHandSideFieldAccess { e: Expr }
                   | LeftHandSideArrayAccess { e: Expr }

/**
 * Statements
 */

.type Statement = Assert                {e: Expr}
                | AssertDetailed        {e1: Expr, e2: Expr}
                | Block                 {s: StatementList}
                | Do                    {e: Expr, s: Statement}
                | For                   {init: ForInitOptional,
                                         cond: ExprOptional,
                                         upd: ForUpdateOptional,
                                         stmt: Statement}
                | Label                 {id: Identifier, s: Statement}
                | IfThen                {e: Expr, s: Statement}
                | IfThenElse            {e: Expr, s1: Statement, s2: Statement}
                | Continue              {e: IdentifierOptional}
                | Break                 {e: IdentifierOptional}
                | Return                {e: ExprOptional}
                | Throw                 {e: Expr}
                | Switch                {e: Expr, s: SwitchRuleList}
                | SynchronizedStatement {e: Expr, s: Statement}
                | While                 {e: Expr, s: Statement}
                | ExprStatement         {e: Expr}
                | Yield                 {e: Expr}
                | EmptyStatement        {}

.type StatementList = [head: Statement, tail: StatementList]

.type Resource = ResourceInitialization {mods: ModifierList,
                                         type: Type,
                                         id: Identifier,
                                         expr: Expr}
               | ResourceAccess         {e: Expr}

.type ResourceList = [head: Resource, tail: ResourceList]

.type ForInit = ForInit {}
.type ForInitOptional = [e: ForInit]

.type CatchFormalParameter = CatchFormalParameter {}
.type CatchClause = CatchClause {param: CatchFormalParameter, b: Statement}

.type ForUpdate = ForUpdate {}
.type ForUpdateOptional = [e: ForUpdate]

.type SwitchLabel = SwitchCase {e: ExprList}
                  | SwitchDefault {}

.type SwitchRule = SwitchRuleExpr  {label: SwitchLabel, s: Expr}
                 | SwitchRuleBlock {label: SwitchLabel, s: Statement}
                 | SwitchRuleThrow {label: SwitchLabel, s: Statement}

.type SwitchRuleList = [
    head: SwitchRule,
    tail: SwitchRuleList
]

/**
 * Types
 */

.type Type = TypeParameter  {modifiers: ModifierList,
                             id: Identifier,
                             bound: TypeBoundOptional}
           | Boolean        {}
           | Byte           {}
           | Short          {}
           | Int            {}
           | Long           {}
           | Var            {}
           | Void           {}
           | Variable       {id: Identifier}
           | TypeVariable   {id: Identifier, annotations: AnnotationList}
           | Char           {}
           | Float          {}
           | Array          {type: Type, dims: DimensionList}
           | Double         {}
           | ClassType      {}
.type TypeList = [head: Type, tail: TypeList]
.type TypeOptional = [t: Type]
.type TypeBound = TypeBound {t: Type, additional: TypeList}
.type TypeBoundOptional = [t: TypeBound]

/* Declarations */

.type Declaration = Class                {modifiers: ModifierList,
                                          id: Identifier,
                                          superclass: TypeOptional,
                                          body: DeclarationList}
                  | Field                {modifiers: ModifierList,
                                          type: Type,
                                          vars: VariableDeclaratorList}
                  | Interface            {modifiers: ModifierList,
                                          id: Identifier}
                  | InstanceInitializer  {statement: Statement}
                  | StaticInitializer    {statement: Statement}
                  | Method               {modifiers: ModifierList,
                                          header: MethodHeader,
                                          body: Statement}
                  | EmptyDeclaration     {}

.type DeclarationList = [head: Declaration, tail: DeclarationList]

/* Enums */

.type EnumBody = EnumBody {constants: EnumConstantList,
                           declarations: DeclarationList}
.type EnumConstant = EnumConstant {modifiers: ModifierList,
                                   id: Identifier,
                                   args: ExprList,
                                   body: DeclarationList}
.type EnumConstantList = [head: EnumConstant, tail: EnumConstantList]

/* Constructors */

.type ExplicitConstructorInvocation = ExplicitConstructorInvocation {}
.type ConstructorBody = ConstructorBody {}
.type ConstructorDeclarator = ConstructorDeclarator {}

/* Methods */

.type MethodHeader = MethodHeader {result: Type}
.type MethodDeclarator = MethodDeclarator {}
.type ReceiverParameter = ReceiverParameter {}
.type FormalParameter = FormalParameter {}
.type FormalParameterList = [head: FormalParameter, tail: FormalParameterList]
.type VariableArityParameter = VariableArityParameter {}

/**
 * Tokens
 **************************************************************************/

.input token
.decl token(s: symbol, c: Identifier, n: number)

.decl token_new(a: number, b: number)
      token_new(A, A + 1) :- token("TOKEN_IDENTIFIER", "new", A).
.decl token_ampersand(a: number, b: number)
      token_ampersand(A, A + 1) :- token("TOKEN_SEPARATOR", "&", A).
.decl token_equal_sign(a: number, b: number)
      token_equal_sign(A, A + 1) :- token("TOKEN_OPERATOR", "=", A).
.decl token_catch(a: number, b: number)
      token_catch(A, A + 1) :- token("TOKEN_KEYWORD", "catch", A).
.decl token_for(a: number, b: number)
      token_for(A, A + 1) :- token("TOKEN_KEYWORD", "for", A).
.decl token_semicolon(a: number, b: number)
      token_semicolon(A, A + 1) :- token("TOKEN_SEPARATOR", ";", A).
.decl token_semicolon?(a: number, b: number)
      token_semicolon?(A, A) :- any_position(A).
      token_semicolon?(A, B) :- token_semicolon(A, B).
.decl token_finally(a: number, b: number)
      token_finally(A, A + 1) :- token("TOKEN_KEYWORD", "finally", A).
.decl token_byte(a: number, b: number)
      token_byte(A, A + 1) :- token("TOKEN_KEYWORD", "byte", A).
.decl token_long(a: number, b: number)
      token_long(A, A + 1) :- token("TOKEN_KEYWORD", "long", A).
.decl token_short(a: number, b: number)
      token_short(A, A + 1) :- token("TOKEN_KEYWORD", "short", A).
.decl token_int(a: number, b: number)
      token_int(A, A + 1) :- token("TOKEN_KEYWORD", "int", A).
.decl token_public(a: number, b: number)
      token_public(A, A + 1) :- token("TOKEN_KEYWORD", "public", A).
.decl token_dot(a: number, b: number)
      token_dot(A, A + 1) :- token("TOKEN_SEPARATOR", ".", A).
.decl token_package(a: number, b: number)
      token_package(A, A + 1) :- token("TOKEN_KEYWORD", "package", A).
.decl token_identifier(id: Identifier, a: number, b: number)
      token_identifier(id, A, A + 1) :- token("TOKEN_IDENTIFIER", id, A).
.decl token_left_paren(a: number, b: number)
      token_left_paren(A, A + 1) :- token("TOKEN_LEFT_PAREN", "(", A).
.decl token_right_paren(a: number, b: number)
      token_right_paren(A, A + 1) :- token("TOKEN_RIGHT_PAREN", ")", A).
.decl token_left_square_bracket(a: number, b: number)
      token_left_square_bracket(A, A + 1) :- token("TOKEN_BRACKET", "[", A).
.decl token_right_square_bracket(a: number, b: number)
      token_right_square_bracket(A, A + 1) :- token("TOKEN_BRACKET", "]", A).
.decl token_left_curly_bracket(a: number, b: number)
      token_left_curly_bracket(A, A + 1) :- token("TOKEN_BRACKET", "{", A).
.decl token_right_curly_bracket(a: number, b: number)
      token_right_curly_bracket(A, A + 1) :- token("TOKEN_BRACKET", "}", A).
.decl token_less_than(a: number, b: number)
      token_less_than(A, A + 1) :- token("TOKEN_OPERATOR", "<", A).
.decl token_greater_than(a: number, b: number)
      token_greater_than(A, A + 1) :- token("TOKEN_OPERATOR", "<", A).
.decl token_asterisk(a: number, b: number)
      token_asterisk(A, A + 1) :- token("TOKEN_OPERATOR", "*", A).
.decl token_import(a: number, b: number)
      token_import(A, A + 1) :- token("TOKEN_KEYWORD", "import", A).
.decl token_comma(a: number, b: number)
      token_comma(A, A + 1) :- token("TOKEN_SEPARATOR", ",", A).
.decl token_comma?(a: number, b: number)
      token_comma?(A, A) :- any_position(A).
      token_comma?(A, B) :- token_comma(A, B).
.decl token_class(a: number, b: number)
      token_class(A, A + 1) :- token("TOKEN_KEYWORD", "class", A).
.decl token_extends(a: number, b: number)
      token_extends(A, A + 1) :- token("TOKEN_KEYWORD", "extends", A).
.decl token_float(a: number, b: number)
      token_float(A, A + 1) :- token("TOKEN_KEYWORD", "float", A).
.decl token_double(a: number, b: number)
      token_double(A, A + 1) :- token("TOKEN_KEYWORD", "double", A).
.decl token_boolean(a: number, b: number)
      token_boolean(A, A + 1) :- token("TOKEN_KEYWORD", "boolean", A).
.decl token_return(a: number, b: number)
      token_return(A, A + 1) :- token("TOKEN_KEYWORD", "return", A).
.decl token_switch(a: number, b: number)
      token_switch(A, A + 1) :- token("TOKEN_KEYWORD", "switch", A).
.decl token_colon(a: number, b: number)
      token_colon(A, A + 1) :- token("TOKEN_SEPARATOR", ":", A).
.decl token_var(a: number, b: number)
      token_var(A, A + 1) :- token("TOKEN_KEYWORD", "var", A).
.decl token_do(a: number, b: number)
      token_do(A, A + 1) :- token("TOKEN_KEYWORD", "do", A).
.decl token_while(a: number, b: number)
      token_while(A, A + 1) :- token("TOKEN_KEYWORD", "while", A).
.decl token_continue(a: number, b: number)
      token_continue(A, A + 1) :- token("TOKEN_KEYWORD", "continue", A).
.decl token_synchronized(a: number, b: number)
      token_synchronized(A, A + 1) :- token("TOKEN_KEYWORD", "synchronized", A).
.decl token_native(a: number, b: number)
      token_native(A, A + 1) :- token("TOKEN_KEYWORD", "native", A).
.decl token_break(a: number, b: number)
      token_break(A, A + 1) :- token("TOKEN_KEYWORD", "break", A).
.decl token_case(a: number, b: number)
      token_case(A, A + 1) :- token("TOKEN_KEYWORD", "case", A).
.decl token_yield(a: number, b: number)
      token_yield(A, A + 1) :- token("TOKEN_KEYWORD", "yield", A).
.decl token_throw(a: number, b: number)
      token_throw(A, A + 1) :- token("TOKEN_KEYWORD", "throw", A).
.decl token_arrow(a: number, b: number)
      token_arrow(A, A + 1) :- token("TOKEN_SEPARATOR", "->", A).
.decl token_if(a: number, b: number)
      token_if(A, A + 1) :- token("TOKEN_KEYWORD", "if", A).
.decl token_else(a: number, b: number)
      token_else(A, A + 1) :- token("TOKEN_KEYWORD", "else", A).
.decl token_assert(a: number, b: number)
      token_assert(A, A + 1) :- token("TOKEN_KEYWORD", "assert", A).
.decl token_static(a: number, b: number)
      token_static(A, A + 1) :- token("TOKEN_KEYWORD", "static", A).
.decl token_transient(a: number, b: number)
      token_transient(A, A + 1) :- token("TOKEN_KEYWORD", "transient", A).
.decl token_volatile(a: number, b: number)
      token_volatile(A, A + 1) :- token("TOKEN_KEYWORD", "volatile", A).
.decl token_question_mark(a: number, b: number)
      token_question_mark(A, A + 1) :- token("TOKEN_SEPARATOR", "?", A).
.decl token_at(a: number, b: number)
      token_at(A, A + 1) :- token("TOKEN_SEPARATOR", "@", A).
.decl token_this(a: number, b: number)
      token_this(A, A + 1) :- token("TOKEN_KEYWORD", "this", A).
.decl token_void(a: number, b: number)
      token_void(A, A + 1) :- token("TOKEN_KEYWORD", "void", A).
.decl token_strictfp(a: number, b: number)
      token_strictfp(A, A + 1) :- token("TOKEN_KEYWORD", "strictfp", A).
.decl token_default(a: number, b: number)
      token_default(A, A + 1) :- token("TOKEN_KEYWORD", "default", A).
.decl token_private(a: number, b: number)
      token_private(A, A + 1) :- token("TOKEN_KEYWORD", "private", A).
.decl token_final(a: number, b: number)
      token_final(A, A + 1) :- token("TOKEN_KEYWORD", "final", A).
.decl token_abstract(a: number, b: number)
      token_abstract(A, A + 1) :- token("TOKEN_KEYWORD", "abstract", A).
.decl token_protected(a: number, b: number)
      token_protected(A, A + 1) :- token("TOKEN_KEYWORD", "protected", A).
.decl token_char(a: number, b: number)
      token_char(A, A + 1) :- token("TOKEN_KEYWORD", "char", A).

/**
 * Helper functions
 **************************************************************************/

.decl any_position(n: number)
any_position(n) :- token(_, _, n).

#define ZERO_OR_MORE(take_many, take_one) \
    take_many(nil, A, A) :- any_position(A). \
    take_many([x, xs], A, C) :- take_one(x, A, B), take_many(xs, B, C).

#define OPTIONAL(take_zero_or_one, take_one) \
    take_zero_or_one(nil, A, A) :- any_position(A). \
    take_zero_or_one([x], A, B) :- take_one(x, A, B).

#define INFIX(node, current_level, next_level, symbol) \
    current_level(node(e1, e2), A, C) :- \
        current_level(e1, A, B), B > A, \
        token("TOKEN_OPERATOR", symbol, B), \
        next_level(e2, B + 1, C), C > B + 1.

#define PREFIX(node, current_level, next_level, symbol) \
    current_level(node(e1), A, B) :- \
        token("TOKEN_OPERATOR", symbol, A), \
        next_level(e1, A + 1, B), B > A + 1.

#define POSTFIX(node, current_level, next_level, symbol) \
    current_level(node(e1), A, B + 1) :- \
        next_level(e1, A, B), B > A, \
        token("TOKEN_OPERATOR", symbol, B).

/**
 * Lexical structure
 * See §3 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl type_identifier(s: Identifier, a: number, b: number)
type_identifier(t, A, B) :- token_identifier(t, A, B).
// TODO not var or yield

.decl identifier(s: Identifier, a: number, b: number)
identifier(t, A, B) :- token_identifier(t, A, B).

.decl identifier?(s: IdentifierOptional, a: number, b: number)
OPTIONAL(identifier?, identifier)

.decl literal(a: number, b: number)

/**
 * Types, Values and Variables
 * See §4 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl type(s: Type, a: number, b: number)
type(e, A, B) :- primitive_type(e, A, B).
type(e, A, B) :- reference_type(e, A, B).

.decl primitive_type(s: Type, a: number, b: number)
primitive_type(e, A, B) :- numeric_type(e, A, B).
primitive_type($Boolean, A, B) :- token_boolean(A, B).
// TODO annotations

.decl numeric_type(s: Type, a: number, b: number)
numeric_type(e, A, B) :- integral_type(e, A, B).
numeric_type(e, A, B) :- floating_point_type(e, A, B).

.decl integral_type(t: Type, a: number, b: number)
integral_type($Byte,  A, B) :- token_byte(A, B).
integral_type($Short, A, B) :- token_short(A, B).
integral_type($Int,   A, B) :- token_int(A, B).
integral_type($Long,  A, B) :- token_long(A, B).
integral_type($Char,  A, B) :- token_char(A, B).

.decl floating_point_type(t: Type, a: number, b: number)
floating_point_type($Float,  A, B) :- token_float(A, B).
floating_point_type($Double, A, B) :- token_double(A, B).

.decl reference_type(t: Type, a: number, b: number)
reference_type(t, A, B) :- class_or_interface_type(t, A, B).
reference_type(t, A, B) :- type_variable(t, A, B).
reference_type(t, A, B) :- array_type(t, A, B).

.decl class_or_interface_type(t: Type, a: number, b: number)
class_or_interface_type(t, A, B) :- class_type(t, A, B).
class_or_interface_type(t, A, B) :- interface_type(t, A, B).

.decl class_type(t: Type, a: number, b: number)

.decl interface_type(t: Type, a: number, b: number)
interface_type(t, A, B) :- class_type(t, A, B).

.decl type_variable(t: Type, a: number, b: number)
type_variable($TypeVariable(id, a), A, B) :-
    annotations?(a, A, B),
    type_identifier(id, A, B).

.decl array_type(t: Type, a: number, b: number)
array_type($Array(b, d), A, C) :- primitive_type(b, A, B), dims(d, B, C).
array_type($Array(b, d), A, C) :-
    class_or_interface_type(b, A, B),
    dims(d, B, C).
array_type($Array(b, d), A, C) :- type_variable(b, A, B), dims(d, B, C).

.decl dims(e: DimensionList, a: number, b: number)
dims([x, nil], A, B) :- dim(x, A, B).
dims([x, xs],  A, C) :- dim(x, A, B), dims(xs, B, C).

.decl dims?(e: DimensionList, a: number, b: number)
dims?(nil, A, A) :- any_position(A).
dims?(x,   A, B) :- dims(x, A, B).

.decl dim(t: Dimension, a: number, b: number)
dim($Dimension(a), A, D) :-
    annotations?(a, A, B),
    token_left_square_bracket(B, C),
    token_right_square_bracket(C, D).

.decl type_parameter(t: Type, a: number, b: number)
type_parameter($TypeParameter(mods, id, bound), A, B) :-
    type_parameter_modifiers?(mods, A, B),
    type_identifier(id, B, C),
    type_bound?(bound, C, D).

.decl type_parameter_modifier(t: Modifier, a: number, b: number)
type_parameter_modifier($AnnotationModifier(t), A, B) :- annotation(t, A, B).

.decl type_parameter_modifiers?(t: ModifierList, a: number, b: number)
ZERO_OR_MORE(type_parameter_modifiers?, type_parameter_modifier)

.decl type_bound(t: TypeBound, a: number, b: number)
type_bound($TypeBound(t, nil), A, B) :- token_extends(A, B), type_variable(t, A, B).
type_bound($TypeBound(t, a), A, D) :-
    token_extends(A, B),
    class_or_interface_type(t, B, C),
    additional_bounds?(a, C, D).

.decl type_bound?(t: TypeBoundOptional, a: number, b: number)
OPTIONAL(type_bound?, type_bound)

.decl additional_bound(t: Type, a: number, b: number)
additional_bound(t, A, C) :-
    token_ampersand(A, B),
    interface_type(t, B, C).

.decl additional_bounds?(t: TypeList, a: number, b: number)
ZERO_OR_MORE(additional_bounds?, additional_bound)

.decl type_arguments(e: TypeList, a: number, b: number)
type_arguments(e, A, D) :-
    token_less_than(A, B),
    type_argument_list(e, B, C),
    token_greater_than(C, D).

.decl type_argument_list(e: TypeList, a: number, b: number)

.decl type_argument(e: Type, a: number, b: number)
type_argument(e, A, B) :- reference_type(e, A, B).

.decl wildcard(a: number, b: number)

.decl wildcard_bounds(a: number, b: number)

/**
 * Names
 * See §6 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl module_name(s: IdentifierList, a: number, b: number)

.decl package_name(s: IdentifierList, a: number, b: number)

.decl type_name(s: IdentifierList, a: number, b: number)
type_name([t, nil], A, B) :- type_identifier(t, A, B).
type_name([t, tail], A, D) :-
    package_or_type_name(tail, A, B),
    token_dot(B, C),
    type_identifier(t, C, D).
// ... reverse?

.decl expression_name(s: IdentifierList, a: number, b: number)
expression_name([id, nil], A, B) :- token_identifier(id, A, B).
expression_name([id, tail], A, D) :-
    ambiguous_name(tail, A, B),
    token_dot(B, C),
    token_identifier(id, C, D).
// ... reverse?

.decl method_name(x: Identifier, a: number, b: number)
method_name(id, A, B) :- token_identifier(id, A, B).
// ... TODO: not yield

.decl package_or_type_name(s: IdentifierList, a: number, b: number)
package_or_type_name([x, nil], A, B) :- token_identifier(x, A, B).
package_or_type_name([x, xs], A, D) :-
    package_or_type_name(xs, A, B),
    token_dot(B, C),
    token_identifier(x, C, D).
// ... reverse?

.decl ambiguous_name(s: IdentifierList, a: number, b: number)
ambiguous_name([x, nil], A, B) :- token_identifier(x, A, B).
ambiguous_name([x, xs], A, D) :-
    ambiguous_name(xs, A, B),
    token_dot(B, C),
    token_identifier(x, C, D).
// ... reverse?

/**
 * Packages and Modules
 * See §7 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl compilation_unit(e: CompilationUnit, a: number, b: number)
compilation_unit(e, A, B) :- ordinary_compilation_unit(e, A, B).
compilation_unit(e, A, B) :- modular_compilation_unit(e, A, B).

.decl ordinary_compilation_unit(e: CompilationUnit, a: number, b: number)

.decl modular_compilation_unit(e: CompilationUnit, a: number, b: number)

.decl package_declaration(e: PackageDeclaration, a: number, b: number)
package_declaration($PackageDeclaration(mods, ids), A, E) :-
    package_modifiers?(mods, A, B),
    token_package(B, C),
    package_declaration_identifiers(ids, C, D),
    token_semicolon(D, E).

.decl package_declaration_identifiers(e: IdentifierList, a: number, b: number)
package_declaration_identifiers([x, nil], A, B) :- identifier(x, A, B).
package_declaration_identifiers([x, xs], A, D) :-
    identifier(x, A, B),
    token_dot(B, C),
    package_declaration_identifiers(xs, C, D).

.decl package_modifier(e: Modifier, a: number, b: number)
package_modifier($AnnotationModifier(e), A, B) :- annotation(e, A, B).

.decl package_modifiers?(e: ModifierList, a: number, b: number)
ZERO_OR_MORE(package_modifiers?, package_modifier)

.decl import_declaration(s: ImportDeclaration, a: number, b: number)
import_declaration(e, A, B) :- single_type_import_declaration(e, A, B).
import_declaration(e, A, B) :- type_import_on_demand_declaration(e, A, B).
import_declaration(e, A, B) :- single_static_import_declaration(e, A, B).
import_declaration(e, A, B) :- static_import_on_demand_declaration(e, A, B).

.decl single_type_import_declaration(s: ImportDeclaration, a: number, b: number)
single_type_import_declaration($Import(syms), A, D) :-
    token_import(A, B),
    type_name(syms, B, C),
    token_semicolon(C, D).

.decl type_import_on_demand_declaration(s: ImportDeclaration, a: number, b: number)
type_import_on_demand_declaration($ImportOnDemandFrom(syms), A, F) :-
    token_import(A, B),
    type_name(syms, B, C),
    token_dot(C, D),
    token_asterisk(D, E),
    token_semicolon(E, F).

.decl single_static_import_declaration(s: ImportDeclaration, a: number, b: number)

.decl static_import_on_demand_declaration(s: ImportDeclaration, a: number, b: number)

.decl type_declaration(s: Declaration, a: number, b: number)
type_declaration(e, A, B) :- class_declaration(e, A, B).
type_declaration(e, A, B) :- interface_declaration(e, A, B).

.decl module_declaration(s: Declaration, a: number, b: number)

.decl module_directive(s: ModuleDirective, a: number, b: number)

.decl requires_modifier(s: Identifier, a: number, b: number)

/**
 * Classes
 * See §8 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl class_declaration(s: Declaration, a: number, b: number)
class_declaration(e, A, B) :- normal_class_declaration(e, A, B).
class_declaration(e, A, B) :- enum_declaration(e, A, B).

.decl normal_class_declaration(s: Declaration, a: number, b: number)
normal_class_declaration($Class(modifiers, id, sup, declarations), A, F) :-
    class_modifiers?(modifiers, A, B),
    token_class(B, C),
    type_identifier(id, C, D),
    superclass?(sup, D, E),
    class_body(declarations, E, F).

.decl class_modifiers?(s: ModifierList, a: number, b: number)
ZERO_OR_MORE(class_modifiers?, class_modifier)

.decl class_modifier(s: Modifier, a: number, b: number)
class_modifier($AnnotationModifier(a),  A, B) :- annotation(a, A, B).
class_modifier($Public,                 A, B) :- token_public(A, B).
class_modifier($Protected,              A, B) :- token_protected(A, B).
class_modifier($Private,                A, B) :- token_private(A, B).
class_modifier($Abstract,               A, B) :- token_abstract(A, B).
class_modifier($Static,                 A, B) :- token_static(A, B).
class_modifier($Final,                  A, B) :- token_final(A, B).
class_modifier($Strictfp,               A, B) :- token_strictfp(A, B).

.decl type_parameters(s: TypeList, a: number, b: number)
type_parameters(nil, A, A) :- any_position(A).
type_parameters(l, A, D) :-
    token_less_than(A, B),
    type_parameter_list(l, B, C),
    token_greater_than(C, D).

.decl type_parameter_list(s: TypeList, a: number, b: number)
type_parameter_list([e, nil], A, B) :- type_parameter(e, A, B).
type_parameter_list([e, tail], A, D) :-
    type_parameter(e, A, B),
    token_comma(B, C),
    type_parameter_list(tail, C, D).

.decl superclass(t: Type, a: number, b: number)
superclass(t, A, C) :-
    token_extends(A, B),
    class_type(t, B, C).

.decl superclass?(t: TypeOptional, a: number, b: number)
OPTIONAL(superclass?, superclass)

.decl superinterfaces(t: Type, a: number, b: number)

// TODO InterfaceTypeList

.decl class_body(s: DeclarationList, a: number, b: number)
class_body(declarations, A, D) :-
    token_left_curly_bracket(A, B),
    class_body_declarations?(declarations, B, C),
    token_right_curly_bracket(C, D).

.decl class_body?(s: DeclarationList, a: number, b: number)
class_body?(nil, A, A) :- any_position(A).
class_body?(x, A, B) :- class_body(x, A, B).

.decl class_body_declarations?(d: DeclarationList, a: number, b: number)
ZERO_OR_MORE(class_body_declarations?, class_body_declaration)

.decl class_body_declaration(d: Declaration, a: number, b: number)
class_body_declaration(e, A, B) :- class_member_declaration(e, A, B).
class_body_declaration(e, A, B) :- instance_initializer(e, A, B).
class_body_declaration(e, A, B) :- static_initializer(e, A, B).
class_body_declaration(e, A, B) :- constructor_declaration(e, A, B).

.decl class_member_declaration(s: Declaration, a: number, b: number)
class_member_declaration(e, A, B) :- field_declaration(e, A, B).
class_member_declaration(e, A, B) :- method_declaration(e, A, B).
class_member_declaration(e, A, B) :- class_declaration(e, A, B).
class_member_declaration(e, A, B) :- interface_declaration(e, A, B).
class_member_declaration($EmptyDeclaration, A, B) :- token_semicolon(A, B).

.decl field_declaration(s: Declaration, a: number, b: number)
field_declaration($Field(mods, type, vars), A, D) :-
    field_modifiers?(mods, A, B),
    unann_type(type, B, C),
    variable_declarator_list(vars, C, D).

.decl field_modifier(s: Modifier, a: number, b: number)
field_modifier($AnnotationModifier(a),  A, B) :- annotation(a, A, B).
field_modifier($Public,                 A, B) :- token_public(A, B).
field_modifier($Protected,              A, B) :- token_protected(A, B).
field_modifier($Private,                A, B) :- token_private(A, B).
field_modifier($Static,                 A, B) :- token_static(A, B).
field_modifier($Final,                  A, B) :- token_final(A, B).
field_modifier($Transient,              A, B) :- token_transient(A, B).
field_modifier($Volatile,               A, B) :- token_volatile(A, B).

.decl field_modifiers?(s: ModifierList, a: number, b: number)
ZERO_OR_MORE(field_modifiers?, field_modifier)

.decl variable_declarator_list(s: VariableDeclaratorList, a: number, b: number)
variable_declarator_list([x, nil], A, B) :- variable_declarator(x, A, B).
variable_declarator_list([x, xs], A, D) :-
    variable_declarator(x, A, B),
    token_comma(B, C),
    variable_declarator_list(xs, C, D).

.decl variable_declarator(s: VariableDeclarator, a: number, b: number)
variable_declarator($VariableDeclarator(id, nil), A, B) :-
    variable_declarator_id(id, A, B).
variable_declarator($VariableDeclarator(id, [init]), A, D) :-
    variable_declarator_id(id, A, B),
    token_equal_sign(B, C),
    variable_initializer(init, C, D).

.decl variable_declarator_id(s: VariableDeclaratorId, a: number, b: number)
variable_declarator_id($VariableDeclaratorId(id), A, B) :- identifier(id, A, B).
variable_declarator_id($VariableDeclaratorArray(id, d), A, C) :-
    identifier(id, A, B),
    dims(d, B, C).

.decl variable_initializer(s: Expr, a: number, b: number)
variable_initializer(e, A, B) :- expression(e, A, B).
variable_initializer(e, A, B) :- array_initializer(e, A, B).

.decl unann_type(t: Type, a: number, b: number)
unann_type(e, A, B) :- unann_primitive_type(e, A, B).
unann_type(e, A, B) :- unann_reference_type(e, A, B).

.decl unann_primitive_type(t: Type, a: number, b: number)
unann_primitive_type($Boolean, A, B) :- token_boolean(A, B).
unann_primitive_type(e, A, B) :- numeric_type(e, A, B).

.decl unann_reference_type(t: Type, a: number, b: number)
unann_reference_type(t, A, B) :- unann_class_or_interface_type(t, A, B).
unann_reference_type(t, A, B) :- unann_type_variable(t, A, B).
unann_reference_type(t, A, B) :- unann_array_type(t, A, B).

.decl unann_class_or_interface_type(t: Type, a: number, b: number)
unann_class_or_interface_type(t, A, B) :- unann_class_type(t, A, B).
unann_class_or_interface_type(t, A, B) :- unann_interface_type(t, A, B).

.decl unann_class_type(t: Type, a: number, b: number)

.decl unann_interface_type(t: Type, a: number, b: number)
unann_interface_type(t, A, B) :- unann_class_type(t, A, B).

.decl unann_type_variable(t: Type, a: number, b: number)
unann_type_variable($Variable(e), A, B) :- type_identifier(e, A, B).

.decl unann_array_type(t: Type, a: number, b: number)
unann_array_type($Array(t, d), A, C) :-
    primitive_type(t, A, B),
    dims(d, B, C).
// ...

.decl method_declaration(s: Declaration, a: number, b: number)
method_declaration($Method(modifiers, header, body), A, D) :-
    method_modifiers?(modifiers, A, B),
    method_header(header, B, C),
    method_body(body, C, D).

.decl method_modifiers?(s: ModifierList, a: number, b: number)
ZERO_OR_MORE(method_modifiers?, method_modifier)

.decl method_modifier(s: Modifier, a: number, b: number)
method_modifier($Public,        A, B) :- token_public(A, B).
method_modifier($Protected,     A, B) :- token_protected(A, B).
method_modifier($Private,       A, B) :- token_private(A, B).
method_modifier($Abstract,      A, B) :- token_abstract(A, B).
method_modifier($Static,        A, B) :- token_static(A, B).
method_modifier($Final,         A, B) :- token_final(A, B).
method_modifier($Synchronized,  A, B) :- token_synchronized(A, B).
method_modifier($Native,        A, B) :- token_native(A, B).
method_modifier($Strictfp,      A, B) :- token_strictfp(A, B).

.decl method_header(s: MethodHeader, a: number, b: number)

.decl result(t: Type, a: number, b: number)
result(t, A, B) :- unann_type(t, A, B).
result($Void, A, B) :- token_void(A, B).

.decl method_declarator(s: MethodDeclarator, a: number, b: number)

.decl receiver_parameter(s: ReceiverParameter, a: number, b: number)

.decl formal_parameter_list(s: FormalParameterList, a: number, b: number)

.decl formal_parameter(s: FormalParameter, a: number, b: number)

.decl variable_arity_parameter(s: VariableArityParameter, a: number, b: number)

.decl variable_modifier(e: Modifier, a: number, b: number)
variable_modifier($Final, A, B) :- token_final(A, B).

.decl variable_modifiers?(e: ModifierList, a: number, b: number)
ZERO_OR_MORE(variable_modifiers?, variable_modifier)

// TODO Throws

// TODO ExceptionTypeList

// TODO ExceptionType

.decl method_body(s: Statement, a: number, b: number)
method_body(e, A, C) :-
    block(e, A, B),
    token_semicolon(B, C).

.decl instance_initializer(s: Declaration, a: number, b: number)
instance_initializer($InstanceInitializer(e), A, B) :- block(e, A, B).

.decl static_initializer(s: Declaration, a: number, b: number)
static_initializer($StaticInitializer(e), A, C) :-
    token_static(A, B),
    block(e, B, C).

.decl constructor_declaration(s: Declaration, a: number, b: number)

.decl constructor_modifier(s: Modifier, a: number, b: number)

.decl constructor_declarator(e: ConstructorDeclarator, a: number, b: number)

.decl simple_type_name(s: symbol, l: number, n: number)
simple_type_name(e, A, B) :- type_identifier(e, A, B).

.decl constructor_body(e: ConstructorBody, a: number, b: number)

.decl explicit_constructor_invocation(e: ExplicitConstructorInvocation, a: number, b: number)

.decl enum_declaration(s: Declaration, a: number, b: number)

.decl enum_body(s: EnumBody, a: number, b: number)
enum_body($EnumBody(con, decl), A, F) :-
    token_left_curly_bracket(A, B),
    enum_constant_list?(con, B, C),
    token_comma?(C, D),
    enum_body_declarations?(decl, D, E),
    token_right_curly_bracket(E, F).

.decl enum_constant_list(e: EnumConstantList, a: number, b: number)
enum_constant_list([x, nil], A, B) :- enum_constant(x, A, B).
enum_constant_list([x, xs], A, D) :-
    enum_constant(x, A, B),
    token_comma(B, C),
    enum_constant_list(xs, C, D).

.decl enum_constant_list?(e: EnumConstantList, a: number, b: number)
enum_constant_list?(nil, A, A) :- any_position(A).
enum_constant_list?(x, A, B) :- enum_constant_list(x, A, B).

.decl enum_constant(e: EnumConstant, a: number, b: number)
enum_constant($EnumConstant(mods, id, nil, body), A, D) :-
    enum_constant_modifiers?(mods, A, B),
    identifier(id, B, C),
    class_body?(body, C, D).
enum_constant($EnumConstant(mods, id, args, body), A, F) :-
    enum_constant_modifiers?(mods, A, B),
    identifier(id, B, C),
    token_left_paren(C, D),
    argument_list?(args, D, E),
    token_right_paren(E, F),
    class_body?(body, F, G).

.decl enum_constant_modifier(e: Modifier, a: number, b: number)
enum_constant_modifier($AnnotationModifier(a), A, B) :- annotation(a, A, B).

.decl enum_constant_modifiers?(e: ModifierList, a: number, b: number)
ZERO_OR_MORE(enum_constant_modifiers?, enum_constant_modifier)

.decl enum_body_declarations(e: DeclarationList, a: number, b: number)
enum_body_declarations(e, A, C) :-
    token_semicolon(A, B),
    class_body_declarations?(e, B, C).

.decl enum_body_declarations?(e: DeclarationList, a: number, b: number)
enum_body_declarations?(nil, A, A) :- any_position(A).
enum_body_declarations?(x, A, B) :- enum_body_declarations(x, A, B).

/**
 * Interfaces
 * See §9 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl interface_declaration(s: Declaration, a: number, b: number)
interface_declaration(e, A, B) :- normal_interface_declaration(e, A, B).
interface_declaration(e, A, B) :- annotation_type_declaration(e, A, B).

.decl normal_interface_declaration(s: Declaration, a: number, b: number)

.decl interface_modifier(m: Modifier, a: number, b: number)
interface_modifier($Public, A, B) :- token_public(A, B).
interface_modifier($Protected, A, B) :- token_protected(A, B).
interface_modifier($Private, A, B) :- token_private(A, B).
interface_modifier($Abstract, A, B) :- token_abstract(A, B).
interface_modifier($Static, A, B) :- token_static(A, B).
interface_modifier($Strictfp, A, B) :- token_strictfp(A, B).

.decl interface_modifiers?(m: ModifierList, a: number, b: number)
ZERO_OR_MORE(interface_modifiers?, interface_modifier)

.decl extends_interfaces(a: number, b: number)

.decl interface_body(a: number, b: number)

.decl interface_member_declaration(a: number, b: number)

.decl constant_declaration(a: number, b: number)

.decl constant_modifier(a: number, b: number)

.decl interface_method_declaration(a: number, b: number)

.decl interface_method_modifier(a: number, b: number)

.decl annotation_type_declaration(s: Declaration, a: number, b: number)

.decl annotation_type_body(a: number, b: number)

.decl annotation_type_member_declaration(a: number, b: number)

.decl annotation_type_element_declaration(a: number, b: number)

.decl annotation_type_element_modifier(m: Modifier, a: number, b: number)
annotation_type_element_modifier($Public, A, B) :- token_public(A, B).
annotation_type_element_modifier($Abstract, A, B) :- token_abstract(A, B).

.decl annotation_type_element_modifiers?(m: ModifierList, a: number, b: number)
ZERO_OR_MORE(annotation_type_element_modifiers?, annotation_type_element_modifier)

.decl default_value(e: ElementValue, a: number, b: number)
default_value(e, A, C) :-
    token_default(A, B),
    element_value(e, B, C).

.decl annotation(e: Annotation, a: number, b: number)
annotation(e, A, B) :- normal_annotation(e, A, B).

.decl annotations?(e: AnnotationList, a: number, b: number)
ZERO_OR_MORE(annotations?, annotation)

.decl normal_annotation(e: Annotation, a: number, b: number)
normal_annotation($Annotation(name, pairs), A, F) :-
    token_at(A, B),
    type_name(name, B, C),
    token_left_paren(C, D),
    element_value_pair_list?(pairs, D, E),
    token_right_paren(E, F).

.decl element_value_pair_list(e: ElementValuePairList, a: number, b: number)
element_value_pair_list([x, nil], A, B) :- element_value_pair(x, A, B).
element_value_pair_list([x, xs], A, B) :-
    element_value_pair(x, A, B),
    token_comma(B, C),
    element_value_pair_list(xs, C, D).

.decl element_value_pair_list?(e: ElementValuePairList, a: number, b: number)
element_value_pair_list?(nil, A, A) :- any_position(A).
element_value_pair_list?(x, A, B) :- element_value_pair_list(x, A, B).

.decl element_value_pair(e: ElementValuePair, a: number, b: number)
element_value_pair($ElementValuePair(id, val), A, B) :-
    identifier(id, A, B),
    token_equal_sign(B, C),
    element_value(val, C, D).

.decl element_value(e: ElementValue, a: number, b: number)
element_value($ElementValueExpr(e), A, B) :- conditional_expression(e, A, B).
element_value($ElementValueArrayInitializer(e), A, B) :- element_value_array_initializer(e, A, B).
element_value($ElementValueAnnotation(e), A, B) :- annotation(e, A, B).

.decl element_value_array_initializer(e: ElementValueList, a: number, b: number)
element_value_array_initializer(e, A, E) :-
    token_left_curly_bracket(A, B),
    element_value_list?(e, B, C),
    token_comma?(C, D),
    token_right_curly_bracket(D, E).

.decl element_value_list(e: ElementValueList, a: number, b: number)
element_value_list([x, nil], A, B) :- element_value(x, A, B).
element_value_list([x, xs], A, D) :-
    element_value(x, A, B),
    token_comma(B, C),
    element_value_list(xs, C, D).

.decl element_value_list?(e: ElementValueList, a: number, b: number)
element_value_list?(nil, A, A) :- any_position(A).
element_value_list?(x, A, B) :- element_value_list(x, A, B).

.decl marker_annotation(e: IdentifierList, a: number, b: number)
marker_annotation(e, A, C) :-
    token_at(A, B),
    type_name(e, B, C).

// TODO SingleElementAnnotation

/**
 * Arrays
 * See §10 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl array_initializer(e: Expr, a: number, b: number)
array_initializer($ArrayInitializer(e), A, E) :- 
    token_left_curly_bracket(A, B),
    variable_initializer_list?(e, B, C),
    token_comma?(C, D),
    token_right_curly_bracket(D, E).

.decl variable_initializer_list(s: ExprList, a: number, b: number)
variable_initializer_list([x, nil], A, A) :- variable_initializer(x, A, B).
variable_initializer_list([x, xs], A, D) :-
    variable_initializer(x, A, B),
    token_comma(B, C),
    variable_initializer_list(xs, C, D).

.decl variable_initializer_list?(s: ExprList, a: number, b: number)
variable_initializer_list?(nil, A, A) :- any_position(A).
variable_initializer_list?(x, A, B) :- variable_initializer_list(x, A, B).

/**
 * Blocks and Statements
 * See §14 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl block(s: Statement, a: number, b: number)
block($Block(s), A, D) :-
    token_left_curly_bracket(A, B),
    block_statements?(s, B, C),
    token_left_curly_bracket(C, D).

.decl block_statements?(s: StatementList, a: number, b: number)
ZERO_OR_MORE(block_statements?, block_statement)

.decl block_statement(s: Statement, a: number, b: number)
block_statement(e, A, B) :- statement(e, A, B).

.decl local_variable_declaration_statement(s: Statement, a: number, b: number)
local_variable_declaration_statement(e, A, C) :-
    local_variable_declaration(e, A, B),
    token_semicolon(B, C).

.decl local_variable_declaration(s: Statement, a: number, b: number)

.decl local_variable_type(t: Type, a: number, b: number)
local_variable_type(t, A, B) :- unann_type(t, A, B).
local_variable_type($Var, A, B) :- token_var(A, B).

.decl statement(s: Statement, a: number, b: number)
statement(e, A, B) :- statement_without_trailing_substatement(e, A, B).
statement(e, A, B) :- labeled_statement(e, A, B).
statement(e, A, B) :- if_then_statement(e, A, B).
statement(e, A, B) :- if_then_else_statement(e, A, B).
statement(e, A, B) :- while_statement(e, A, B).
statement(e, A, B) :- for_statement(e, A, B).

.decl statement_no_short_if(s: Statement, a: number, b: number)
statement_no_short_if(e, A, B) :- statement_without_trailing_substatement(e, A, B).
statement_no_short_if(e, A, B) :- labeled_statement_no_short_if(e, A, B).
statement_no_short_if(e, A, B) :- if_then_else_statement_no_short_if(e, A, B).
statement_no_short_if(e, A, B) :- while_statement_no_short_if(e, A, B).
statement_no_short_if(e, A, B) :- for_statement_no_short_if(e, A, B).

.decl statement_without_trailing_substatement(s: Statement, a: number, b: number)
statement_without_trailing_substatement(e, A, B) :- block(e, A, B).
statement_without_trailing_substatement(e, A, B) :- empty_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- expression_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- assert_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- switch_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- do_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- break_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- continue_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- return_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- synchronized_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- throw_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- try_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- yield_statement(e, A, B).

.decl empty_statement(s: Statement, a: number, b: number)
empty_statement($EmptyStatement, A, B) :- token_semicolon(A, B).

.decl labeled_statement(s: Statement, a: number, b: number)
labeled_statement($Label(id, st), A, D) :-
    token_identifier(id, A, B),
    token_colon(B, C),
    statement(st, C, D).

.decl labeled_statement_no_short_if(s: Statement, a: number, b: number)
labeled_statement_no_short_if($Label(id, st), A, B) :-
    token_identifier(id, A, B),
    token_colon(B, C),
    statement_no_short_if(st, C, D).

.decl expression_statement(e: Statement, a: number, b: number)
expression_statement($ExprStatement(e), A, C) :-
    statement_expression(e, A, B),
    token_semicolon(B, C).

.decl statement_expression(e: Expr, a: number, b: number)
statement_expression(e, A, B) :- assignment(e, A, B).
statement_expression(e, A, B) :- pre_increment_expression(e, A, B).
statement_expression(e, A, B) :- pre_decrement_expression(e, A, B).
statement_expression(e, A, B) :- post_increment_expression(e, A, B).
statement_expression(e, A, B) :- post_decrement_expression(e, A, B).
statement_expression(e, A, B) :- method_invocation(e, A, B).
statement_expression(e, A, B) :- class_instance_creation_expression(e, A, B).

.decl if_then_statement(s: Statement, a: number, b: number)
if_then_statement($IfThen(e, s), A, F) :-
    token_if(A, B),
    token_left_paren(B, C),
    expression(e, C, D),
    token_right_paren(D, E),
    statement(s, E, F).

.decl if_then_else_statement(s: Statement, a: number, b: number)
if_then_else_statement($IfThenElse(e, s1, s2), A, H) :-
    token_if(A, B),
    token_left_paren(B, C),
    expression(e, C, D),
    token_right_paren(D, E),
    statement_no_short_if(s1, E, F),
    token_else(F, G),
    statement(s2, G, H).

.decl if_then_else_statement_no_short_if(s: Statement, a: number, b: number)
if_then_else_statement_no_short_if($IfThenElse(e, s1, s2), A, H) :-
    token_if(A, B),
    token_left_paren(B, C),
    expression(e, C, D),
    token_right_paren(D, E),
    statement_no_short_if(s1, E, F),
    token_else(F, G),
    statement_no_short_if(s2, G, H).

.decl assert_statement(s: Statement, a: number, b: number)
assert_statement($Assert(e), A, D) :-
    token_assert(A, B),
    expression(e, B, C),
    token_semicolon(C, D).
assert_statement($AssertDetailed(e1, e2), A, F) :-
    token_assert(A, B),
    expression(e1, B, C),
    token_colon(C, D),
    expression(e2, D, E),
    token_semicolon(E, F).

.decl switch_statement(s: Statement, a: number, b: number)
switch_statement($Switch(e, rules), A, F) :-
    token_switch(A, B),
    token_left_paren(B, C),
    expression(e, C, D),
    token_right_paren(D, E),
    switch_block(rules, E, F).

.decl switch_block(s: SwitchRuleList, a: number, b: number)
switch_block([rule, rules], A, E) :-
    token_left_curly_bracket(A, B),
    switch_rule(rule, B, C),
    switch_rules?(rules, C, D),
    token_right_curly_bracket(D, E).

.decl switch_rules?(e: SwitchRuleList, a: number, b: number)
ZERO_OR_MORE(switch_rules?, switch_rule)

.decl switch_rule(e: SwitchRule, a: number, b: number)
switch_rule($SwitchRuleExpr(label, expr), A, E) :-
    switch_label(label, A, B),
    token_arrow(B, C),
    expression(expr, C, D),
    token_semicolon(D, E).
switch_rule($SwitchRuleBlock(label, stmt), A, D) :-
    switch_label(label, A, B),
    token_arrow(B, C),
    block(stmt, C, D).
switch_rule($SwitchRuleBlock(label, stmt), A, C) :-
    switch_label(label, A, B),
    token_arrow(B, C),
    throw_statement(stmt, C, D).

.decl switch_block_statement_group(a: number, b: number)

.decl switch_label(s: SwitchLabel, a: number, b: number)
switch_label($SwitchDefault, A, B) :- token_default(A, B).
switch_label($SwitchCase(exprs), A, C) :-
    token_case(A, B),
    case_constants(exprs, B, C).

.decl case_constants(e: ExprList, a: number, b: number)
case_constants([x, nil], A, B) :- case_constant(x, A, B).
case_constants([x, xs], A, D) :-
    case_constant(x, A, B),
    token_comma(B, C),
    case_constants(xs, C, D).

.decl case_constant(e: Expr, a: number, b: number)
case_constant(e, A, B) :- conditional_expression(e, A, B).

.decl while_statement(s: Statement, a: number, b: number)
while_statement($While(e, s), A, F) :-
    token_while(A, B),
    token_left_paren(B, C),
    expression(e, C, D),
    token_right_paren(D, E),
    statement(s, E, F).

.decl while_statement_no_short_if(s: Statement, a: number, b: number)
while_statement_no_short_if($While(e, s), A, F) :-
    token_while(A, B),
    token_left_paren(B, C),
    expression(e, C, D),
    token_right_paren(D, E),
    statement_no_short_if(s, E, F).

.decl do_statement(s: Statement, a: number, b: number)
do_statement($Do(e, s), A, H) :-
    token_do(A, B),
    statement(s, B, C),
    token_while(C, D),
    token_left_paren(D, E),
    expression(e, E, F),
    token_right_paren(F, G),
    token_semicolon(G, H).

.decl for_statement(s: Statement, a: number, b: number)
for_statement(e, A, B) :- for_statement_no_short_if(e, A, B).
for_statement(e, A, B) :- enhanced_for_statement(e, A, B).

.decl for_statement_no_short_if(s: Statement, a: number, b: number)
for_statement_no_short_if(e, A, B) :- basic_for_statement_no_short_if(e, A, B).
for_statement_no_short_if(e, A, B) :- enhanced_for_statement_no_short_if(e, A, B).

.decl basic_for_statement(s: Statement, a: number, b: number)
basic_for_statement($For(init, expr, upd, stat), A, J) :-
    token_for(A, B),
    token_left_paren(B, C),
    for_init?(init, C, D),
    token_semicolon(D, E),
    expression?(expr, E, F),
    token_semicolon(F, G),
    for_update?(upd, G, H),
    token_right_paren(H, I),
    statement(stat, I, J).

.decl basic_for_statement_no_short_if(s: Statement, a: number, b: number)
basic_for_statement($For(init, expr, upd, stat), A, J) :-
    token_for(A, B),
    token_left_paren(B, C),
    for_init?(init, C, D),
    token_semicolon(D, E),
    expression?(expr, E, F),
    token_semicolon(F, G),
    for_update?(upd, G, H),
    token_right_paren(H, I),
    statement_no_short_if(stat, I, J).

.decl for_init(s: ForInit, a: number, b: number)
for_init($ForInit, A, B) :- statement_expression_list(_, A, B).
for_init($ForInit, A, B) :- local_variable_declaration(_, A, B).
.decl for_init?(s: ForInitOptional, a: number, b: number)
OPTIONAL(for_init?, for_init)

.decl for_update(s: ForUpdate, a: number, b: number)
for_update($ForUpdate, A, B) :- statement_expression_list(e, A, B).
.decl for_update?(s: ForUpdateOptional, a: number, b: number)
OPTIONAL(for_update?, for_update)

.decl statement_expression_list(s: ExprList, a: number, b: number)
statement_expression_list([x, nil], A, B) :- statement_expression(x, A, B).
statement_expression_list([x, xs], A, D) :-
    statement_expression(x, A, B),
    token_comma(B, C),
    statement_expression_list(xs, C, D).

.decl enhanced_for_statement(s: Statement, a: number, b: number)

.decl enhanced_for_statement_no_short_if(s: Statement, a: number, b: number)

.decl break_statement(s: Statement, a: number, b: number)
break_statement($Break(id), A, D) :-
    token_break(A, B),
    identifier?(id, B, C),
    token_semicolon(C, D).

.decl yield_statement(s: Statement, a: number, b: number)
yield_statement($Yield(e), A, D) :-
    token_yield(A, B),
    expression(e, B, C),
    token_semicolon(C, D).

.decl continue_statement(s: Statement, a: number, b: number)
continue_statement($Continue(id), A, D) :-
    token_continue(A, B),
    identifier?(id, B, C),
    token_semicolon(C, D).

.decl return_statement(s: Statement, a: number, b: number)
return_statement($Return(e), A, D) :-
    token_return(A, B),
    expression?(e, B, C),
    token_semicolon(C, D).

.decl throw_statement(s: Statement, a: number, b: number)
throw_statement($Throw(e), A, D) :-
    token_throw(A, B),
    expression(e, B, C),
    token_semicolon(C, D).

.decl synchronized_statement(s: Statement, a: number, b: number)
synchronized_statement($SynchronizedStatement(e, s), A, F) :-
    token_synchronized(A, B),
    token_left_paren(B, C),
    expression(e, C, D),
    token_right_paren(D, E),
    block(s, E, F).

.decl try_statement(s: Statement, a: number, b: number)

// TODO Catches

.decl catch_clause(e: CatchClause, a: number, b: number)
catch_clause($CatchClause(param, b), A, B) :-
    token_catch(A, B),
    token_left_paren(B, C),
    catch_formal_parameter(param, C, D),
    token_right_paren(D, E),
    block(b, E, F).

.decl catch_formal_parameter(e: CatchFormalParameter, a: number, b: number)

// TODO CatchType

.decl finally(e: Statement, a: number, b: number)
finally(b, A, B) :-
    token_finally(A, B),
    block(b, B, C).

// TODO TryWithResourcesStatement

// TODO ResourceSpecification
.decl resource_specification(e: ResourceList, a: number, b: number)
resource_specification(e, A, E) :-
    token_left_paren(A, B),
    resource_list(e, B, C),
    token_semicolon?(C, D),
    token_right_paren(D, E).

.decl resource_list(e: ResourceList, a: number, b: number)
resource_list([x, nil], A, B) :- resource(x, A, B).
resource_list([x, xs], A, D) :-
    resource(x, A, B),
    token_semicolon(B, C),
    resource_list(xs, C, D).

.decl resource(e: Resource, a: number, b: number)
resource($ResourceInitialization(mods, type, id, expr), A, F) :-
    variable_modifiers?(mods, A, B),
    local_variable_type(type, B, C),
    identifier(id, C, D),
    token_equal_sign(D, E),
    expression(expr, E, F).
resource($ResourceAccess(e), A, B) :-
    variable_access(e, A, B).

.decl variable_access(e: Expr, a: number, b: number)

/**
 * Expressions
 * See §15 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl primary(e: Expr, a: number, b: number)
primary(e, A, B) :- primary_no_new_array(e, A, B).
primary(e, A, B) :- array_creation_expression(e, A, B).

.decl primary_no_new_array(e: Expr, a: number, b: number)
primary_no_new_array($Literal, A, B) :- literal(A, B).
primary_no_new_array(e, A, B) :- class_literal(e, A, B).
primary_no_new_array($This, A, B) :- token_this(A, B).
primary_no_new_array(e, A, B + 1) :-
    token_left_paren(A, B),
    expression(e, B, C),
    token_right_paren(C, D).
primary_no_new_array(e, A, B) :- class_instance_creation_expression(e, A, B).
primary_no_new_array(e, A, B) :- field_access(e, A, B).
primary_no_new_array(e, A, B) :- array_access(e, A, B).
primary_no_new_array(e, A, B) :- method_invocation(e, A, B).
primary_no_new_array(e, A, B) :- method_reference(e, A, B).

.decl class_literal(e: Expr, a: number, b: number)

.decl class_instance_creation_expression(e: Expr, a: number, b: number)

.decl unqualified_class_instance_creation_expression(e: Expr, a: number, b: number)

.decl class_or_interface_type_to_instantiate(e: Expr, a: number, b: number)

.decl type_arguments_or_diamond(e: Expr, a: number, b: number)

.decl field_access(e: Expr, a: number, b: number)

.decl array_access(e: Expr, a: number, b: number)
array_access($ArrayAccessIdentifier(id, expr), A, D) :-
    expression_name(id, A, B),
    token_left_square_bracket(B, C),
    expression(expr, C, D),
    token_right_square_bracket(D, E).
array_access($ArrayAccessExpr(e1, e2), A, D) :-
    primary_no_new_array(e1, A, B),
    token_left_square_bracket(B, C),
    expression(e2, C, D),
    token_right_square_bracket(D, E).

.decl method_invocation(e: Expr, a: number, b: number)
method_invocation(e, A, B) :- method_invocation_with_method_name(e, A, B).

.decl method_invocation_with_method_name(e: Expr, a: number, b: number)
method_invocation_with_method_name($MethodInvocation(id, e), A, E) :-
    method_name(id, A, B),
    token_left_paren(B, C),
    argument_list?(e, C, D),
    token_right_paren(D, E).

.decl argument_list?(e: ExprList, a: number, b: number)
argument_list?(nil, A, A) :- any_position(A).
argument_list?(e, A, B) :- argument_list(e, A, B).

.decl argument_list(e: ExprList, a: number, b: number)
argument_list([x, nil], A, B) :- expression(x, A, B).
argument_list([x, xs], A, D) :-
    expression(x, A, B),
    token_comma(B, C),
    argument_list(xs, C, D).

.decl method_reference(e: Expr, a: number, b: number)

.decl array_creation_expression(e: Expr, a: number, b: number)
array_creation_expression($ArrayCreation(t, de, d), A, E) :-
    token_new(A, B),
    primitive_type(t, B, C),
    dim_exprs(de, C, D),
    dims?(d, D, E).
array_creation_expression($ArrayCreation(t, de, d), A, E) :-
    token_new(A, B),
    class_or_interface_type(t, B, C),
    dim_exprs(de, C, D),
    dims?(d, D, E).
array_creation_expression($ArrayCreationWithInitializer(t,d,init), A, E) :-
    token_new(A, B),
    primitive_type(t, B, C),
    dims(d, C, D),
    array_initializer(init, D, E).
array_creation_expression($ArrayCreationWithInitializer(t,d,init), A, E) :-
    token_new(A, B),
    class_or_interface_type(t, B, C),
    dims(d, C, D),
    array_initializer(init, D, E).

.decl dim_exprs(e: ExprList, a: number, b: number)
dim_exprs([x, nil], A, B) :- dim_expr(x, A, B).
dim_exprs([x, xs], A, C) :-
    dim_expr(x, A, B),
    dim_exprs(xs, B, C).

.decl dim_expr(e: Expr, a: number, b: number)
dim_expr($DimensionExpr(a, e), A, E) :-
    annotations?(a, A, B),
    token_left_square_bracket(B, C),
    expression(e, C, D),
    token_right_square_bracket(D, E).

.decl expression(e: Expr, a: number, b: number)
expression(e, A, B) :- conditional_expression(e, A, B).
expression(e, A, B) :- lambda_expression(e, A, B).

.decl expression?(e: ExprOptional, a: number, b: number)
OPTIONAL(expression?, expression)

.decl lambda_expression(e: Expr, a: number, b: number)
lambda_expression($Lambda(params, body), A, D) :-
    lambda_parameters(params, A, B),
    token_arrow(B, C),
    lambda_body(body, C, D).

.decl lambda_parameters(e: LambdaParameters, a: number, b: number)
lambda_parameters($LambdaParametersIdentifier(id), A, B) :-
    identifier(id, A, B).
lambda_parameters($LambdaParametersIdentifierList(ids), A, D) :-
    token_left_paren(A, B),
    lambda_parameter_list_first_option(ids, B, C),
    token_right_paren(C, D).
lambda_parameters($LambdaParametersLambdaParameterList(params), A, D) :-
    token_left_paren(A, B),
    lambda_parameter_list_second_option(params, B, C),
    token_right_paren(C, D).

/* Note: Rule lambda_parameter_list is handled by the two following rules */
.decl lambda_parameter_list_first_option(e: IdentifierList, a: number, b: number)
lambda_parameter_list_first_option([x, nil], A, B) :- identifier(x, A, B).
lambda_parameter_list_first_option([x, xs], A, D) :-
    identifier(x, A, B),
    token_comma(B, C),
    lambda_parameter_list_first_option(xs, C, D).
.decl lambda_parameter_list_second_option(e: LambdaParameterList, a: number, b: number)
lambda_parameter_list_second_option([x, nil], A, B) :- lambda_parameter(x, A, B).
lambda_parameter_list_second_option([x, xs], A, D) :-
    lambda_parameter(x, A, B),
    token_comma(B, C),
    lambda_parameter_list_second_option(xs, C, D).

.decl lambda_parameter(e: LambdaParameter, a: number, b: number)
lambda_parameter($LambdaParameter(mods, t, decl), A, D) :-
    variable_modifiers?(mods, A, B),
    lambda_parameter_type(t, B, C),
    variable_declarator_id(decl, C, D).
lambda_parameter($LambdaParameterVariableArity(p), A, B) :-
    variable_arity_parameter(p, A, B).

.decl lambda_parameter_type(t: Type, a: number, b: number)
lambda_parameter_type(t, A, B) :- unann_type(t, A, B).
lambda_parameter_type($Var, A, B) :- token_var(A, B).

.decl lambda_body(e: LambdaBody, a: number, b: number)
lambda_body($LambdaBodyExpr(e), A, B) :- expression(e, A, B).
lambda_body($LambdaBodyBlock(e), A, B) :- block(e, A, B).

.decl assignment_expression(e: Expr, a: number, b: number)
assignment_expression(e, A, B) :- conditional_expression(e, A, B).
assignment_expression(e, A, B) :- assignment(e, A, B).

.decl assignment(e: Expr, a: number, b: number)
assignment($Assign(e1, s, e2), A, D) :-
    left_hand_side(e1, A, B),
    assignment_operator(s, B, C),
    expression(e2, C, D).

.decl left_hand_side(e: LeftHandSide, a: number, b: number)
left_hand_side($LeftHandSideName(n), A, B) :-
    expression_name(n, A, B).
left_hand_side($LeftHandSideFieldAccess(e), A, B) :-
    field_access(e, A, B).
left_hand_side($LeftHandSideArrayAccess(e), A, B) :-
    array_access(e, A, B).

.decl assignment_operator(s: symbol, a: number, b: number)
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "*=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "/=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "%=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "+=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "-=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "<<=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = ">>=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = ">>>=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "&=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "^=".
assignment_operator(s, A, A + 1) :- token(_, s, A), s = "|=".

.decl conditional_expression(e: Expr, a: number, b: number)
conditional_expression(e, A, B) :- conditional_or_expression(e, A, B).
conditional_expression(e, A, F) :-
    conditional_or_expression(e, A, B),
    token_question_mark(B, C),
    expression(e, C, D),
    token_colon(D, E),
    conditional_expression(e, E, F).
conditional_expression(e, A, F) :-
    conditional_or_expression(e, A, B),
    token_question_mark(B, C),
    expression(e, C, D),
    token_colon(D, E),
    lambda_expression(e, E, F).

.decl conditional_or_expression(e: Expr, a: number, b: number)
conditional_or_expression(e, A, B) :- conditional_and_expression(e, A, B).
INFIX($Or, conditional_or_expression, conditional_and_expression, "||")

.decl conditional_and_expression(e: Expr, a: number, b: number)
conditional_and_expression(e, A, B) :- inclusive_or_expression(e, A, B).
INFIX($And, conditional_and_expression, inclusive_or_expression, "&&")

.decl inclusive_or_expression(e: Expr, a: number, b: number)
inclusive_or_expression(e, A, B) :- exclusive_or_expression(e, A, B).
INFIX($BitwiseInclOr, inclusive_or_expression, exclusive_or_expression, "|")

.decl exclusive_or_expression(e: Expr, a: number, b: number)
exclusive_or_expression(e, A, B) :- and_expression(e, A, B).
INFIX($BitwiseExclOr, exclusive_or_expression, and_expression, "^")

.decl and_expression(e: Expr, a: number, b: number)
and_expression(e, A, B) :- equality_expression(e, A, B).
INFIX($BitwiseAnd, and_expression, equality_expression, "&")

.decl equality_expression(e: Expr, a: number, b: number)
equality_expression(e, A, B) :-       relational_expression(e, A, B).
INFIX($Equal,    equality_expression, relational_expression, "==")
INFIX($NotEqual, equality_expression, relational_expression, "!=")

.decl relational_expression(e: Expr, a: number, b: number)
relational_expression(e, A, B) :- shift_expression(e, A, B).

.decl shift_expression(e: Expr, a: number, b: number)
shift_expression(e, A, B) :- additive_expression(e, A, B).
INFIX($ShiftLeft,          shift_expression, additive_expression, "<<")
INFIX($ShiftRight,         shift_expression, additive_expression, ">>")
INFIX($ShiftRightUnsigned, shift_expression, additive_expression, ">>>")

.decl additive_expression(e: Expr, a: number, b: number)
additive_expression(e, A, B) :- multiplicative_expression(e, A, B).
INFIX($Add, additive_expression, multiplicative_expression, "+")
INFIX($Sub, additive_expression, multiplicative_expression, "-")

.decl multiplicative_expression(e: Expr, a: number, b: number)
multiplicative_expression(e, A, B) :- unary_expression(e, A, B).
INFIX($Mul, multiplicative_expression, unary_expression, "*")
INFIX($Div, multiplicative_expression, unary_expression, "/")
INFIX($Mod, multiplicative_expression, unary_expression, "%")

.decl unary_expression(e: Expr, a: number, b: number)
unary_expression(e, A, B) :- postfix_expression(e, A, B).
unary_expression(e, A, B) :- pre_increment_expression(e, A, B).
unary_expression(e, A, B) :- pre_decrement_expression(e, A, B).

.decl pre_increment_expression(e: Expr, a: number, b: number)
PREFIX($PreIncrement, pre_increment_expression, unary_expression, "++")

.decl pre_decrement_expression(e: Expr, a: number, b: number)
PREFIX($PreDecrement, pre_decrement_expression, unary_expression, "--")

.decl unary_expression_not_plus_minus(e: Expr, a: number, b: number)
unary_expression_not_plus_minus(e, A, B) :- postfix_expression(e, A, B).
PREFIX($BitwiseNot, unary_expression_not_plus_minus, unary_expression, "~")
PREFIX($Not, unary_expression_not_plus_minus, unary_expression, "!")

.decl postfix_expression(e: Expr, a: number, b: number)
postfix_expression(e, A, B) :- post_increment_expression(e, A, B).
postfix_expression(e, A, B) :- post_decrement_expression(e, A, B).
postfix_expression($Identifier(id), A, B) :- token_identifier(id, A, B).
postfix_expression($Number(to_number(n)), A, A + 1) :- token("TOKEN_NUMBER", n, A).

.decl post_increment_expression(e: Expr, a: number, b: number)
POSTFIX($PostIncrement, post_increment_expression, postfix_expression, "++")
.decl post_decrement_expression(e: Expr, a: number, b: number)
POSTFIX($PostDecrement, post_decrement_expression, postfix_expression, "--")

.decl cast_expression(e: Expr, a: number, b: number)
cast_expression($Cast(t, nil, e), A, E) :-
    token_left_paren(A, B),
    primitive_type(t, B, C),
    token_right_paren(C, D),
    unary_expression(e, D, E).
cast_expression($Cast(t, b, e), A, F) :-
    token_left_paren(A, B),
    reference_type(t, B, C),
    additional_bounds?(b, C, D),
    token_right_paren(D, E),
    unary_expression_not_plus_minus(e, E, F).
cast_expression($Cast(t, b, e), A, F) :-
    token_left_paren(A, B),
    reference_type(t, B, C),
    additional_bounds?(b, C, D),
    token_right_paren(D, E),
    lambda_expression(e, E, F).

.decl switch_expression(e: Expr, a: number, b: number)
switch_expression($SwitchExpr(e1, rules), A, F) :-
    token_switch(A, B),
    token_left_paren(B, C),
    expression(e1, C, D),
    token_right_paren(D, E),
    switch_block(rules, E, F).

.decl constant_expression(e: Expr, a: number, b: number)
constant_expression(e, A, B) :- expression(e, A, B).

/**
 * Output
 **************************************************************************/

.decl root(s: Statement)
root(s) :-
    statement(s, 1, N),
    token("TOKEN_EOF", _, N + 1).

.output expression
.output return_statement
.output statement
.output class_modifiers?
.output type_identifier
.output class_body
.output continue_statement
.output method_invocation
.output normal_class_declaration
.output argument_list?
.output class_declaration
