.type Expression = Number {n: number}
                 | Identifier {id: symbol}
                 | Equal {e1: Expression, e2: Expression}
                 | NotEqual {e1: Expression, e2: Expression}
                 | Add {e1: Expression, e2: Expression}
                 | Mul {e1: Expression, e2: Expression}
                 | Sub {e1: Expression, e2: Expression}
                 | Mod {e1: Expression, e2: Expression}
                 | ShiftLeft {e1: Expression, e2: Expression}
                 | BitwiseInclOr {e1: Expression, e2: Expression}
                 | BitwiseExclOr {e1: Expression, e2: Expression}
                 | BitwiseAnd {e1: Expression, e2: Expression}
                 | BitwiseNot {e1: Expression}
                 | Not {e1: Expression}
                 | Or {e1: Expression, e2: Expression}
                 | PreIncrement {e1: Expression}
                 | PostIncrement {e1: Expression}
                 | PreDecrement {e1: Expression}
                 | PostDecrement {e1: Expression}
                 | And {e1: Expression, e2: Expression}
                 | ShiftRight {e1: Expression, e2: Expression}
                 | ShiftRightUnsigned {e1: Expression, e2: Expression}
                 | Div {e1: Expression, e2: Expression}
                 | Assign {e1: Expression, e2: Expression}
                 | LessThan {e1: Expression, e2: Expression}

.type Statement = If {cond: Expression, then: Statement}
                | While {cond: Expression, then: Statement}
                | Do {cond: Expression, then: Statement}
                | Block {s: StatementList }
                | Return {e: Expression }
                | Yield {e: Expression }
                | Empty {}

.type StatementList = [
    head: Statement,
    tail: StatementList
]

.decl token(s: symbol, c: symbol, n: number)
/* statement */
.decl statement(s: Statement, n: number, l: number)
.decl one_or_more_statements(s: StatementList, n: number, l: number)
/* expressions */
.decl expression(e: Expression, n: number, l: number)
.decl inclusive_or_expression(e: Expression, n: number, l: number)
.decl pre_increment_expression(e: Expression, n: number, l: number)
.decl pre_decrement_expression(e: Expression, n: number, l: number)
.decl post_increment_expression(e: Expression, n: number, l: number)
.decl exclusive_or_expression(e: Expression, n: number, l: number)
.decl assignment_expression(e: Expression, n: number, l: number)
.decl conditional_expression(e: Expression, n: number, l: number)
.decl equality_expression(e: Expression, n: number, l: number)
.decl post_decrement_expression(e: Expression, n: number, l: number)
.decl conditional_or_expression(e: Expression, n: number, l: number)
.decl unary_expression_not_plus_minus(e: Expression, n: number, l: number)
.decl postfix_expression(e: Expression, n: number, l: number)
.decl conditional_and_expression(e: Expression, n: number, l: number)
.decl and_expression(e: Expression, n: number, l: number)
.decl relational_expression(e: Expression, n: number, l: number)
.decl shift_expression(e: Expression, n: number, l: number)
.decl expression_name(e: Expression, n: number, l: number)
.decl additive_expression(e: Expression, n: number, l: number)
.decl multiplicative_expression(e: Expression, n: number, l: number)
.decl unary_expression(e: Expression, n: number, l: number)
/* root */
.decl root(s: Statement)

.input token

/**
 * Blocks/statements
 */

one_or_more_statements([e, nil], A, B) :-
    statement(e, A, B).

one_or_more_statements([e, tail], A, C) :-
    statement(e, A, B), B >= A,
    one_or_more_statements(tail, B + 1, C), C >= B + 1.

statement($Block(nil), A, A + 1) :-
    token("TOKEN_BRACKET", "{", A),
    token("TOKEN_BRACKET", "}", A + 1).

statement($Block(s), A, B + 1) :-
    token("TOKEN_BRACKET", "{", A),
    one_or_more_statements(s, A + 1, B), B >= A + 1,
    token("TOKEN_BRACKET", "}", B + 1).

statement($If(cond, then), A, C) :-
    token("TOKEN_KEYWORD", "if", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(cond, A + 2, B), B >= A + 2,
    token("TOKEN_BRACKET", ")", B + 1),
    statement(then, B + 2, C),  C >= B + 2.

statement($Do(cond, do), A, C + 2) :-
    token("TOKEN_KEYWORD", "do", A),
    statement(do, A + 1, B),  B >= A + 1,
    token("TOKEN_KEYWORD", "while", B + 1),
    token("TOKEN_BRACKET", "(", B + 2),
    expression(cond, B + 3, C), C >= B + 3,
    token("TOKEN_BRACKET", ")", C + 1),
    token("TOKEN_SEPARATOR", ";", C + 2).

statement($While(cond, do), A, C) :-
    token("TOKEN_KEYWORD", "while", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(cond, A + 2, B), B >= A + 2,
    token("TOKEN_BRACKET", ")", B + 1),
    statement(do, B + 2, C),  C >= B + 2.

statement($Return(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "return", A),
    expression(e, A + 1, B), B >= A + 1,
    token("TOKEN_SEPARATOR", ";", B + 1).

statement($Yield(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "yield", A),
    expression(e, A + 1, B), B >= A + 1,
    token("TOKEN_SEPARATOR", ";", B + 1).

/**
 * Expressions
 */

#define INFIXOP(node, current_level, next_level, symbol) \
    current_level(node(e1, e2), A, C) :- \
        current_level(e1, A, B), B >= A, \
        token("TOKEN_OPERATOR", symbol, B + 1), \
        next_level(e2, B + 2, C), C >= B + 2.

#define PREFIXOP(node, current_level, next_level, symbol) \
    current_level(node(e1), A, B) :- \
        token("TOKEN_OPERATOR", symbol, A), \
        next_level(e1, A + 1, B), B >= A + 1.

#define POSTFIXOP(node, current_level, next_level, symbol) \
    current_level(node(e1), A, B + 1) :- \
        next_level(e1, A, B), B >= A, \
        token("TOKEN_OPERATOR", symbol, B + 1).

expression(e, A, B) :- conditional_expression(e, A, B).

assignment_expression(e, A, B) :- conditional_expression(e, A, B).

conditional_expression(e, A, B) :- conditional_or_expression(e, A, B).
conditional_expression(e, A, D) :-
    conditional_or_expression(e, A, B), B >= A,
    token("TOKEN_SEPARATOR", "?", B + 1),
    expression(e, B + 2, C), C >= B + 2,
    token("TOKEN_SEPARATOR", ":", C + 1),
    conditional_expression(e, C+2, D), D >= C + 2.
// TODO: lambda

conditional_or_expression(e, A, B) :- conditional_and_expression(e, A, B).
INFIXOP($Or, conditional_or_expression, conditional_and_expression, "||")

conditional_and_expression(e, A, B) :- inclusive_or_expression(e, A, B).
INFIXOP($And, conditional_and_expression, inclusive_or_expression, "&&")

inclusive_or_expression(e, A, B) :- exclusive_or_expression(e, A, B).
INFIXOP($BitwiseInclOr, inclusive_or_expression, exclusive_or_expression, "|")

exclusive_or_expression(e, A, B) :- and_expression(e, A, B).
INFIXOP($BitwiseExclOr, exclusive_or_expression, and_expression, "^")

and_expression(e, A, B) :- equality_expression(e, A, B).
INFIXOP($BitwiseAnd, and_expression, equality_expression, "&")

equality_expression(e, A, B) :-       relational_expression(e, A, B).
INFIXOP($Equal,    equality_expression, relational_expression, "==")
INFIXOP($NotEqual, equality_expression, relational_expression, "!=")

relational_expression(e, A, B) :- shift_expression(e, A, B).

shift_expression(e, A, B) :- additive_expression(e, A, B).
INFIXOP($ShiftLeft,          shift_expression, additive_expression, "<<")
INFIXOP($ShiftRight,         shift_expression, additive_expression, ">>")
INFIXOP($ShiftRightUnsigned, shift_expression, additive_expression, ">>>")

additive_expression(e, A, B) :- multiplicative_expression(e, A, B).
INFIXOP($Add, additive_expression, multiplicative_expression, "+")
INFIXOP($Sub, additive_expression, multiplicative_expression, "-")

multiplicative_expression(e, A, B) :- unary_expression(e, A, B).
INFIXOP($Mul, multiplicative_expression, unary_expression, "*")
INFIXOP($Div, multiplicative_expression, unary_expression, "/")
INFIXOP($Mod, multiplicative_expression, unary_expression, "%")

unary_expression(e, A, B) :- postfix_expression(e, A, B).
unary_expression(e, A, B) :- pre_increment_expression(e, A, B).
unary_expression(e, A, B) :- pre_decrement_expression(e, A, B).

PREFIXOP($PreIncrement, pre_increment_expression, unary_expression, "++")
PREFIXOP($PreDecrement, pre_decrement_expression, unary_expression, "--")

unary_expression_not_plus_minus(e, A, B) :- postfix_expression(e, A, B).
PREFIXOP($BitwiseNot, unary_expression_not_plus_minus, unary_expression, "~")
PREFIXOP($Not, unary_expression_not_plus_minus, unary_expression, "!")

postfix_expression(e, A, B) :- expression_name(e, A, B).
postfix_expression(e, A, B) :- post_increment_expression(e, A, B).
postfix_expression(e, A, B) :- post_decrement_expression(e, A, B).

POSTFIXOP($PostIncrement, post_increment_expression, postfix_expression, "++")
POSTFIXOP($PostDecrement, post_decrement_expression, postfix_expression, "--")

// TODO
expression_name($Identifier(id), A, A) :- token("TOKEN_IDENTIFIER", id, A).
expression_name($Number(to_number(n)), A, A) :- token("TOKEN_NUMBER", n, A).

/**
 * Root
 */

root(s) :- statement(s, 1, N), token("TOKEN_EOF", _, N+1).

.output expression
