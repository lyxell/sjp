/**
 * MIT License
 *
 * Copyright (c) 2021 Anton Lyxell
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Types
 **************************************************************************/

.type id = [type: symbol, from: number, to: number]
.type id_list = [head: id, tail: id_list]

/**
 * Tokens
 **************************************************************************/

.input token
.decl token(s: symbol, n: number)

.input token_type
.decl token_type(n: number, s: symbol)

.input num_tokens
.decl num_tokens(n: number)

.decl token_implements(a: number, b: number)
      token_implements(A, A + 1) :- token("implements", A).
.decl token_requires(a: number, b: number)
      token_requires(A, A + 1) :- token("requires", A).
.decl token_transitive(a: number, b: number)
      token_transitive(A, A + 1) :- token("transitive", A).
.decl token_exports(a: number, b: number)
      token_exports(A, A + 1) :- token("exports", A).
.decl token_provides(a: number, b: number)
      token_provides(A, A + 1) :- token("provides", A).
.decl token_to(a: number, b: number)
      token_to(A, A + 1) :- token("to", A).
.decl token_uses(a: number, b: number)
      token_uses(A, A + 1) :- token("uses", A).
.decl token_opens(a: number, b: number)
      token_opens(A, A + 1) :- token("opens", A).
.decl token_with(a: number, b: number)
      token_with(A, A + 1) :- token("with", A).
.decl token_try(a: number, b: number)
      token_try(A, A + 1) :- token("try", A).
.decl token_new(a: number, b: number)
      token_new(A, A + 1) :- token("new", A).
.decl token_super(a: number, b: number)
      token_super(A, A + 1) :- token("super", A).
.decl token_ellipsis(a: number, b: number)
      token_ellipsis(A, A + 1) :- token("...", A).
.decl token_ampersand(a: number, b: number)
      token_ampersand(A, A + 1) :- token("&", A).
.decl token_equal_sign(a: number, b: number)
      token_equal_sign(A, A + 1) :- token("=", A).
.decl token_vertical_bar(a: number, b: number)
      token_vertical_bar(A, A + 1) :- token("|", A).
.decl token_catch(a: number, b: number)
      token_catch(A, A + 1) :- token("catch", A).
.decl token_for(a: number, b: number)
      token_for(A, A + 1) :- token("for", A).
.decl token_semicolon(a: number, b: number)
      token_semicolon(A, A + 1) :- token(";", A).
.decl token_semicolon?(a: number, b: number)
      token_semicolon?(A, A) :- any_position(A).
      token_semicolon?(A, B) :- token_semicolon(A, B).
.decl token_finally(a: number, b: number)
      token_finally(A, A + 1) :- token("finally", A).
.decl token_byte(a: number, b: number)
      token_byte(A, A + 1) :- token("byte", A).
.decl token_long(a: number, b: number)
      token_long(A, A + 1) :- token("long", A).
.decl token_short(a: number, b: number)
      token_short(A, A + 1) :- token("short", A).
.decl token_int(a: number, b: number)
      token_int(A, A + 1) :- token("int", A).
.decl token_public(a: number, b: number)
      token_public(A, A + 1) :- token("public", A).
.decl token_dot(a: number, b: number)
      token_dot(A, A + 1) :- token(".", A).
.decl token_package(a: number, b: number)
      token_package(A, A + 1) :- token("package", A).
.decl token_literal_integer(s: symbol, a: number, b: number)
      token_literal_integer(s, A, A + 1) :-
      token_type(A, "integer"),
      token(s, A).
.decl token_identifier(s: symbol, a: number, b: number)
      token_identifier(s, A, A + 1) :-
      token_type(A, "identifier"),
      token(s, A).
.decl token_left_paren(a: number, b: number)
      token_left_paren(A, A + 1) :- token("(", A).
.decl token_right_paren(a: number, b: number)
      token_right_paren(A, A + 1) :- token(")", A).
.decl token_left_square_bracket(a: number, b: number)
      token_left_square_bracket(A, A + 1) :- token("[", A).
.decl token_right_square_bracket(a: number, b: number)
      token_right_square_bracket(A, A + 1) :- token("]", A).
.decl token_left_curly_bracket(a: number, b: number)
      token_left_curly_bracket(A, A + 1) :- token("{", A).
.decl token_right_curly_bracket(a: number, b: number)
      token_right_curly_bracket(A, A + 1) :- token("}", A).
.decl token_less_than(a: number, b: number)
      token_less_than(A, A + 1) :- token("<", A).
.decl token_greater_than(a: number, b: number)
      token_greater_than(A, A + 1) :- token(">", A).
.decl token_asterisk(a: number, b: number)
      token_asterisk(A, A + 1) :- token("*", A).
.decl token_import(a: number, b: number)
      token_import(A, A + 1) :- token("import", A).
.decl token_comma(a: number, b: number)
      token_comma(A, A + 1) :- token(",", A).
.decl token_comma?(a: number, b: number)
      token_comma?(A, A) :- any_position(A).
      token_comma?(A, B) :- token_comma(A, B).
.decl token_interface(a: number, b: number)
      token_interface(A, A + 1) :- token("interface", A).
.decl token_class(a: number, b: number)
      token_class(A, A + 1) :- token("class", A).
.decl token_extends(a: number, b: number)
      token_extends(A, A + 1) :- token("extends", A).
.decl token_float(a: number, b: number)
      token_float(A, A + 1) :- token("float", A).
.decl token_double(a: number, b: number)
      token_double(A, A + 1) :- token("double", A).
.decl token_boolean(a: number, b: number)
      token_boolean(A, A + 1) :- token("boolean", A).
.decl token_return(a: number, b: number)
      token_return(A, A + 1) :- token("return", A).
.decl token_switch(a: number, b: number)
      token_switch(A, A + 1) :- token("switch", A).
.decl token_colon(a: number, b: number)
      token_colon(A, A + 1) :- token(":", A).
.decl token_var(a: number, b: number)
      token_var(A, A + 1) :- token("var", A).
.decl token_do(a: number, b: number)
      token_do(A, A + 1) :- token("do", A).
.decl token_while(a: number, b: number)
      token_while(A, A + 1) :- token("while", A).
.decl token_continue(a: number, b: number)
      token_continue(A, A + 1) :- token("continue", A).
.decl token_synchronized(a: number, b: number)
      token_synchronized(A, A + 1) :- token("synchronized", A).
.decl token_native(a: number, b: number)
      token_native(A, A + 1) :- token("native", A).
.decl token_break(a: number, b: number)
      token_break(A, A + 1) :- token("break", A).
.decl token_case(a: number, b: number)
      token_case(A, A + 1) :- token("case", A).
.decl token_yield(a: number, b: number)
      token_yield(A, A + 1) :- token("yield", A).
.decl token_throws(a: number, b: number)
      token_throws(A, A + 1) :- token("throws", A).
.decl token_throw(a: number, b: number)
      token_throw(A, A + 1) :- token("throw", A).
.decl token_arrow(a: number, b: number)
      token_arrow(A, A + 1) :- token("->", A).
.decl token_if(a: number, b: number)
      token_if(A, A + 1) :- token("if", A).
.decl token_else(a: number, b: number)
      token_else(A, A + 1) :- token("else", A).
.decl token_assert(a: number, b: number)
      token_assert(A, A + 1) :- token("assert", A).
.decl token_static(a: number, b: number)
      token_static(A, A + 1) :- token("static", A).
.decl token_transient(a: number, b: number)
      token_transient(A, A + 1) :- token("transient", A).
.decl token_volatile(a: number, b: number)
      token_volatile(A, A + 1) :- token("volatile", A).
.decl token_question_mark(a: number, b: number)
      token_question_mark(A, A + 1) :- token("?", A).
.decl token_at(a: number, b: number)
      token_at(A, A + 1) :- token("@", A).
.decl token_this(a: number, b: number)
      token_this(A, A + 1) :- token("this", A).
.decl token_void(a: number, b: number)
      token_void(A, A + 1) :- token("void", A).
.decl token_strictfp(a: number, b: number)
      token_strictfp(A, A + 1) :- token("strictfp", A).
.decl token_default(a: number, b: number)
      token_default(A, A + 1) :- token("default", A).
.decl token_private(a: number, b: number)
      token_private(A, A + 1) :- token("private", A).
.decl token_final(a: number, b: number)
      token_final(A, A + 1) :- token("final", A).
.decl token_abstract(a: number, b: number)
      token_abstract(A, A + 1) :- token("abstract", A).
.decl token_protected(a: number, b: number)
      token_protected(A, A + 1) :- token("protected", A).
.decl token_char(a: number, b: number)
      token_char(A, A + 1) :- token("char", A).

/**
 * Helper functions
 **************************************************************************/

.decl any_position(n: number)
any_position(n) :- token(_, n).
any_position(n) :- num_tokens(n).

#define ZERO_OR_MORE(take_many, take_one) \
    take_many(nil, A, A) :- any_position(A). \
    take_many([x, xs], A, C) :- take_many(xs, B, C), take_one(x, A, B).

#define OPTIONAL(take_zero_or_one, take_one) \
    take_zero_or_one(nil, A, A) :- any_position(A). \
    take_zero_or_one([x], A, B) :- take_one(x, A, B).

#define ID_OPTIONAL(take_zero_or_one, take_one) \
    take_zero_or_one(nil, A, A) :- any_position(A). \
    take_zero_or_one(x, A, B) :- take_one(x, A, B).

#define INFIX(node, rule_name, current_level, next_level, symbol) \
    in_tree(l), \
    in_tree(r) :- \
        rule_name(id, l, r, _, _), \
        in_tree(id). \
    .decl rule_name(id: id, left: id, right: id, a: number, b: number) \
    rule_name([node, A, C], left, right, A, C) :- \
        current_level(left, A, B), \
        token(symbol, B), \
        next_level(right, B + 1, C).

#define PREFIX(node, current_level, next_level, symbol) \
    current_level([node, A, B], A, B) :- \
        token(symbol, A), \
        next_level(_, A + 1, B).

#define POSTFIX(node, current_level, next_level, symbol) \
    current_level([node, A, B], A, B + 1) :- \
        next_level(_, A, B), \
        token(symbol, B).

/**
 * Lexical structure
 * See §3 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl type_identifier(id: id, a: number, b: number)
type_identifier(["type_identifier", A, B], A, B) :- token_identifier(_, A, B).

.decl identifier(id: id, a: number, b: number)
identifier(["identifier", A, B], A, B) :- token_identifier(_, A, B).

.decl identifier?(id: id, a: number, b: number)
ID_OPTIONAL(identifier?, identifier)

.decl literal(id: id, a: number, b: number)
literal(["integer_literal", A, B], A, B) :- token_literal_integer(_, A, B).

/**
 * Types, Values and Variables
 * See §4 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl type(id: id, a: number, b: number)
type(e, A, B) :- primitive_type(e, A, B).
type(e, A, B) :- reference_type(e, A, B).

.decl primitive_type(id: id, a: number, b: number)
primitive_type(e, A, B) :- numeric_type(e, A, B).
primitive_type(["boolean_type", A, B], A, B) :- token_boolean(A, B).
// TODO annotations

.decl numeric_type(id: id, a: number, b: number)
numeric_type(id, A, B) :- integral_type(id, A, B).
numeric_type(id, A, B) :- floating_point_type(id, A, B).

.decl integral_type(id: id, a: number, b: number)
integral_type(["byte_type", A, B],  A, B) :- token_byte(A, B).
integral_type(["short_type", A, B], A, B) :- token_short(A, B).
integral_type(["int_type", A, B],   A, B) :- token_int(A, B).
integral_type(["long_type", A, B],  A, B) :- token_long(A, B).
integral_type(["char_type", A, B],  A, B) :- token_char(A, B).

.decl floating_point_type(id: id, a: number, b: number)
floating_point_type(["float_type", A, B],  A, B) :- token_float(A, B).
floating_point_type(["double_type", A, B], A, B) :- token_double(A, B).

.decl reference_type(id: id, a: number, b: number)
reference_type(t, A, B) :- class_or_interface_type(t, A, B).
reference_type(t, A, B) :- array_type(t, A, B).
// Note: the derivation of TypeVariable is omitted to handle an ambiguity in
// the Java grammar specification. The same derivation is handled by
// ClassOrInterfaceType → ClassType → {Annotation} TypeIdentifier

.decl class_or_interface_type(id: id, a: number, b: number)
class_or_interface_type(t, A, B) :- class_type(t, A, B).
class_or_interface_type(t, A, B) :- interface_type(t, A, B).

.decl class_type(id: id, a: number, b: number)
class_type(nil, A, D) :-
    annotations?(_, A, B),
    type_identifier(_, B, C),
    type_arguments?(_, C, D).
class_type(nil, A, F) :-
    package_name(_, A, B),
    token_dot(B, C),
    annotations?(_, C, D),
    type_identifier(_, D, E),
    type_arguments?(_, E, F).
class_type(nil, A, F) :-
    class_or_interface_type(_, A, B),
    token_dot(B, C),
    annotations?(_, C, D),
    type_identifier(_, D, E),
    type_arguments?(_, E, F).

.decl interface_type(id: id, a: number, b: number)
interface_type(t, A, B) :- class_type(t, A, B).

.decl type_variable(id: id, a: number, b: number)
type_variable(["type_variable", A, B], A, C) :-
    annotations?(_, A, B),
    type_identifier(_, B, C).

.decl array_type(id: id, a: number, b: number)
array_type(["array_type", A, C], A, C) :-
    primitive_type(_, A, B),
    dims(_, B, C).
array_type(["array_type", A, C], A, C) :-
    class_or_interface_type(_, A, B),
    dims(_, B, C).
// Note: the derivation of TypeVariable is omitted to handle an ambiguity in
// the Java specification. The same derivation is handled by
// ClassOrInterfaceType → ClassType → {Annotation} TypeIdentifier

.decl dims(ids: id_list, a: number, b: number)
dims([x, nil], A, B) :- dim(x, A, B).
dims([x, xs],  A, C) :- dim(x, A, B), dims(xs, B, C).

.decl dims?(ids: id_list, a: number, b: number)
dims?(nil, A, A) :- any_position(A).
dims?(x,   A, B) :- dims(x, A, B).

.decl dim(id: id, a: number, b: number)
dim(["dimension", A, D], A, D) :-
    annotations?(_, A, B),
    token_left_square_bracket(B, C),
    token_right_square_bracket(C, D).

.decl type_parameter(id: id, a: number, b: number)
type_parameter(nil, A, D) :-
    type_parameter_modifiers?(_, A, B),
    type_identifier(_, B, C),
    type_bound?(_, C, D).

.decl type_parameter_modifier(id: id, a: number, b: number)
type_parameter_modifier(["annotation_modifier", A, B], A, B) :-
    annotation(t, A, B).

.decl type_parameter_modifiers?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(type_parameter_modifiers?, type_parameter_modifier)

.decl type_bound(id: id, a: number, b: number)
type_bound(nil, A, D) :-
    token_extends(A, B),
    class_or_interface_type(_, B, C),
    additional_bounds?(_, C, D).
// Note: the derivation of TypeVariable is omitted to handle an ambiguity in
// the Java grammar specification. The same derivation is handled by
// ClassOrInterfaceType → ClassType → {Annotation} TypeIdentifier

.decl type_bound?(id: id, a: number, b: number)
ID_OPTIONAL(type_bound?, type_bound)

.decl additional_bound(id: id, a: number, b: number)
additional_bound(id, A, C) :-
    token_ampersand(A, B),
    interface_type(id, B, C).

.decl additional_bounds?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(additional_bounds?, additional_bound)

.decl type_arguments(ids: id_list, a: number, b: number)
type_arguments(e, A, D) :-
    token_less_than(A, B),
    type_argument_list(e, B, C),
    token_greater_than(C, D).

.decl type_arguments?(ids: id_list, a: number, b: number)
type_arguments?(nil, A, A) :- any_position(A).
type_arguments?(x, A, B) :- type_arguments(x, A, B).

.decl type_argument_list(ids: id_list, a: number, b: number)
type_argument_list([x, nil], A, B) :- type_argument(x, A, B).
type_argument_list([x, xs], A, C) :-
    type_argument(x, A, B),
    type_argument_list(xs, B, C).

.decl type_argument(id: id, a: number, b: number)
type_argument(e, A, B) :- reference_type(e, A, B).

.decl wildcard(id: id, a: number, b: number)
wildcard(nil, A, D) :-
    annotations?(_, A, B),
    token_question_mark(B, C),
    wildcard_bounds(_, C, D).

.decl wildcard_bounds(id: id, a: number, b: number)
wildcard_bounds(nil, A, C) :-
    token_extends(A, B),
    reference_type(_, B, C).
wildcard_bounds(nil, A, C) :-
    token_super(A, B),
    reference_type(_, B, C).

/**
 * Names
 * See §6 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl module_name(id: id, children: id_list, a: number, b: number)
module_name(["module_name", A, B], [x, nil], A, B) :- identifier(x, A, B).
module_name(["module_name", A, D], [x, xs], A, D) :-
    module_name(_, xs, A, B),
    token_dot(B, C),
    identifier(x, C, D).

.decl package_name(ids: id_list, a: number, b: number)
package_name([x, nil], A, B) :- identifier(x, A, B).
package_name([x, xs], A, D) :-
    package_name(xs, A, B),
    token_dot(B, C),
    identifier(x, C, D).

.decl type_name(id: id, a: number, b: number)
type_name(["type_name", A, B], A, B) :- type_identifier(_, A, B).
type_name(["type_name", A, D], A, D) :-
    package_or_type_name(_, A, B),
    token_dot(B, C),
    type_identifier(_, C, D).

.decl expression_name(ids: id_list, a: number, b: number)
expression_name([["identifier", A, B], nil], A, B) :- token_identifier(_, A, B).
expression_name([["identifier", C, D], tail], A, D) :-
    ambiguous_name(tail, A, B),
    token_dot(B, C),
    token_identifier(id, C, D).

.decl method_name(id: id, a: number, b: number)
method_name(nil, A, B) :- token_identifier(_, A, B).
// ... TODO: not yield

.decl package_or_type_name(id: id, a: number, b: number)
package_or_type_name(["package_or_type_name", A, B], A, B) :-
    token_identifier(_, A, B).
package_or_type_name(["package_or_type_name", A, D], A, D) :-
    package_or_type_name(_, A, B),
    token_dot(B, C),
    token_identifier(_, C, D).

.decl ambiguous_name(ids: id_list, a: number, b: number)
ambiguous_name([["identifier", A, B], nil], A, B) :- token_identifier(x, A, B).
ambiguous_name([["identifier", C, D], xs], A, D) :-
    ambiguous_name(xs, A, B),
    token_dot(B, C),
    token_identifier(x, C, D).

/**
 * Packages and Modules
 * See §7 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl compilation_unit(id: id, a: number, b: number)
compilation_unit(id, A, B) :- ordinary_compilation_unit(id, _, _, _, A, B).
compilation_unit(id, A, B) :- modular_compilation_unit(id, A, B).

.decl ordinary_compilation_unit(id: id,
                                package_declaration: id,
                                import_declarations: id_list,
                                type_declarations: id_list,
                                a: number,
                                b: number)
ordinary_compilation_unit(["ordinary_compilation_unit", A, D],
                          pd, ids, tds, A, D) :-
    package_declaration?(pd, A, B),
    import_declarations?(ids, B, C),
    type_declarations?(tds, C, D).

.decl modular_compilation_unit(id: id, a: number, b: number)
modular_compilation_unit(["modular_compilation_unit", A, C], A, C) :-
    import_declarations?(_, A, B),
    module_declaration(_, B, C).

.decl package_declaration(id: id, a: number, b: number)
package_declaration(["package_declaration", A, E], A, E) :-
    package_modifiers?(_, A, B),
    token_package(B, C),
    package_declaration_identifiers(_, C, D),
    token_semicolon(D, E).

.decl package_declaration?(id: id, a: number, b: number)
ID_OPTIONAL(package_declaration?, package_declaration)

.decl package_declaration_identifiers(id: id_list, a: number, b: number)
package_declaration_identifiers([x, nil], A, B) :- identifier(x, A, B).
package_declaration_identifiers([x, xs], A, D) :-
    identifier(x, A, B),
    token_dot(B, C),
    package_declaration_identifiers(xs, C, D).

.decl package_modifier(id: id, a: number, b: number)
package_modifier(["annotation_modifier", A, B], A, B) :- annotation(_, A, B).

.decl package_modifiers?(id: id_list, a: number, b: number)
ZERO_OR_MORE(package_modifiers?, package_modifier)

.decl import_declaration(id: id, a: number, b: number)
import_declaration(id, A, B) :- single_type_import_declaration(id, _, A, B).
import_declaration(id, A, B) :- type_import_on_demand_declaration(id, A, B).
import_declaration(id, A, B) :- single_static_import_declaration(id, A, B).
import_declaration(id, A, B) :- static_import_on_demand_declaration(id, A, B).

.decl import_declarations?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(import_declarations?, import_declaration)

.decl single_type_import_declaration(id: id, name: id, a: number, b: number)
single_type_import_declaration(["single_type_import_declaration", A, D], name,
                               A, D) :-
    token_import(A, B),
    type_name(name, B, C),
    token_semicolon(C, D).

.decl type_import_on_demand_declaration(id: id, a: number, b: number)
type_import_on_demand_declaration(["type_import_on_demand_declaration", A, F],
                                  A, F) :-
    token_import(A, B),
    type_name(_, B, C),
    token_dot(C, D),
    token_asterisk(D, E),
    token_semicolon(E, F).

.decl single_static_import_declaration(id: id, a: number, b: number)
single_static_import_declaration(["single_static_import_declaration", A, G],
                                 A, G) :-
    token_import(A, B),
    token_static(B, C),
    type_name(_, C, D),
    token_dot(D, E),
    identifier(_, E, F),
    token_semicolon(F, G).

.decl static_import_on_demand_declaration(id: id, a: number, b: number)
static_import_on_demand_declaration(["static_import_on_demand_declaration",
                                     A, G], A, G) :-
    token_import(A, B),
    token_static(B, C),
    type_name(_, C, D),
    token_dot(D, E),
    token_asterisk(E, F),
    token_semicolon(F, G).

.decl type_declaration(s: id, a: number, b: number)
type_declaration(id, A, B) :- class_declaration(id, A, B).
type_declaration(id, A, B) :- interface_declaration(id, A, B).

.decl type_declarations?(s: id_list, a: number, b: number)
ZERO_OR_MORE(type_declarations?, type_declaration)

.decl module_declaration(id: id, a: number, b: number)

.decl module_directive(id: id, a: number, b: number)
module_directive(["module_directive", A, E], A, E) :-
    token_requires(A, B),
    requires_modifiers?(_, B, C),
    module_name(_, _, C, D),
    token_semicolon(D, E).
module_directive(["module_directive", A, D], A, D) :-
    token_exports(A, B),
    package_name(_, B, C),
    token_semicolon(C, D).
module_directive(["module_directive", A, F], A, F) :-
    token_exports(A, B),
    package_name(_, B, C),
    token_to(C, D),
    module_directive_module_name_list(_, _, D, E),
    token_semicolon(E, F).
module_directive(["module_directive", A, D], A, D) :-
    token_opens(A, B),
    package_name(_, B, C),
    token_semicolon(C, D).
module_directive(["module_directive", A, F], A, F) :-
    token_opens(A, B),
    package_name(_, B, C),
    token_to(C, D),
    module_directive_module_name_list(_, _, D, E),
    token_semicolon(E, F).
module_directive(["module_directive", A, D], A, D) :-
    token_uses(A, B),
    type_name(t, B, C),
    token_semicolon(C, D).
module_directive(["module_directive", A, F], A, F) :-
    token_provides(A, B),
    type_name(_, B, C),
    token_with(C, D),
    module_directive_type_name_list(_, _, D, E),
    token_semicolon(E, F).

.decl module_directives?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(module_directives?, module_directive)

.decl module_directive_module_name_list(id: id, children: id_list,
                                        a: number, b: number)
module_directive_module_name_list(["module_directive_module_name_list", A, B],
                                  [x, nil], A, B) :-
    module_name(x, _, A, B).
module_directive_module_name_list(["module_directive_module_name_list", A, B],
                                  [x, xs], A, D) :-
    module_name(x, _, A, B),
    token_comma(B, C),
    module_directive_module_name_list(_, xs, C, D).

.decl module_directive_type_name_list(id: id, children: id_list,
                                      a: number, b: number)
module_directive_type_name_list(["module_directive_type_name_list", A, B],
                                [x, nil], A, B) :- type_name(x, A, B).
module_directive_type_name_list(["module_directive_type_name_list", A, D],
                                [x, xs], A, D) :-
    type_name(x, A, B),
    token_comma(B, C),
    module_directive_type_name_list(_, xs, C, D).

.decl requires_modifier(id: id, a: number, b: number)
requires_modifier(["static_modifier", A, B], A, B) :- token_static(A, B).
requires_modifier(["transitive_modifier", A, B], A, B) :- token_transitive(A, B).

.decl requires_modifiers?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(requires_modifiers?, requires_modifier)

/**
 * Classes
 * See §8 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl class_declaration(id: id, a: number, b: number)
class_declaration(id, A, B) :- normal_class_declaration(id, _, _, A, B).
class_declaration(id, A, B) :- enum_declaration(id, A, B).

.decl normal_class_declaration(id: id, mods: id_list,
                               body: id_list, a: number, b: number)
normal_class_declaration(["normal_class_declaration", A, F], m, body, A, F) :-
    class_modifiers?(m, A, B),
    token_class(B, C),
    type_identifier(_, C, D),
    superclass?(_, D, E),
    class_body(body, E, F).

.decl class_modifiers?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(class_modifiers?, class_modifier)

.decl class_modifier(s: id, a: number, b: number)
class_modifier(["annotation_modifier", A, B],  A, B) :- annotation(_, A, B).
class_modifier(["public_modifier", A, B], A, B) :- token_public(A, B).
class_modifier(["protected_modifier", A, B],  A, B) :- token_protected(A, B).
class_modifier(["private_modifier", A, B], A, B) :- token_private(A, B).
class_modifier(["abstract_modifier", A, B], A, B) :- token_abstract(A, B).
class_modifier(["static_modifier", A, B], A, B) :- token_static(A, B).
class_modifier(["final_modifier", A, B], A, B) :- token_final(A, B).
class_modifier(["strictfp_modifier", A, B], A, B) :- token_strictfp(A, B).

.decl type_parameters(ids: id_list, a: number, b: number)
type_parameters(nil, A, A) :- any_position(A).
type_parameters(l, A, D) :-
    token_less_than(A, B),
    type_parameter_list(l, B, C),
    token_greater_than(C, D).

.decl type_parameter_list(ids: id_list, a: number, b: number)
type_parameter_list([e, nil], A, B) :- type_parameter(e, A, B).
type_parameter_list([e, tail], A, D) :-
    type_parameter(e, A, B),
    token_comma(B, C),
    type_parameter_list(tail, C, D).

.decl superclass(id: id, a: number, b: number)
superclass(id, A, C) :-
    token_extends(A, B),
    class_type(id, B, C).

.decl superclass?(id: id, a: number, b: number)
ID_OPTIONAL(superclass?, superclass)

.decl superinterfaces(ids: id_list, a: number, b: number)
superinterfaces(ids, A, C) :-
    token_implements(A, B),
    interface_type_list(ids, B, C).


.decl interface_type_list(ids: id_list, a: number, b: number)
interface_type_list([x, nil], A, B) :- interface_type(x, A, B).
interface_type_list([x, xs], A, D) :-
    interface_type(x, A, B),
    token_comma(B, C),
    interface_type_list(xs, C, D).

.decl class_body(id: id_list, a: number, b: number)
class_body(declarations, A, D) :-
    token_left_curly_bracket(A, B),
    class_body_declarations?(declarations, B, C),
    token_right_curly_bracket(C, D).

.decl class_body?(s: id_list, a: number, b: number)
class_body?(nil, A, A) :- any_position(A).
class_body?(x, A, B) :- class_body(x, A, B).

.decl class_body_declarations?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(class_body_declarations?, class_body_declaration)

.decl class_body_declaration(id: id, a: number, b: number)
class_body_declaration(e, A, B) :- class_member_declaration(e, A, B).
class_body_declaration(e, A, B) :- instance_initializer(e, A, B).
class_body_declaration(e, A, B) :- static_initializer(e, A, B).
class_body_declaration(e, A, B) :- constructor_declaration(e, A, B).

.decl class_member_declaration(id: id, a: number, b: number)
class_member_declaration(id, A, B) :- field_declaration(id, A, B).
class_member_declaration(id, A, B) :- method_declaration(id, _, _, _, A, B).
class_member_declaration(id, A, B) :- class_declaration(id, A, B).
class_member_declaration(id, A, B) :- interface_declaration(id, A, B).
class_member_declaration(nil, A, B) :- token_semicolon(A, B).

.decl field_declaration(id: id, a: number, b: number)
field_declaration(["field_declaration", A, E], A, E) :-
    field_modifiers?(_, A, B),
    unann_type(_, B, C),
    variable_declarator_list(_, C, D),
    token_semicolon(D, E).

.decl field_modifier(id: id, a: number, b: number)
field_modifier(["annotation_modifier", A, B], A, B) :- annotation(a, A, B).
field_modifier(["public_modifier", A, B], A, B) :- token_public(A, B).
field_modifier(["protected_modifier", A, B], A, B) :- token_protected(A, B).
field_modifier(["private_modifier", A, B], A, B) :- token_private(A, B).
field_modifier(["static_modifier", A, B], A, B) :- token_static(A, B).
field_modifier(["final_modifier", A, B], A, B) :- token_final(A, B).
field_modifier(["transient_modifier", A, B], A, B) :- token_transient(A, B).
field_modifier(["volatile_modifier", A, B], A, B) :- token_volatile(A, B).

.decl field_modifiers?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(field_modifiers?, field_modifier)

.decl variable_declarator_list(id: id_list, a: number, b: number)
variable_declarator_list([x, nil], A, B) :- variable_declarator(x, _, _, A, B).
variable_declarator_list([x, xs], A, D) :-
    variable_declarator(x, _, _, A, B),
    token_comma(B, C),
    variable_declarator_list(xs, C, D).

.decl variable_declarator(id: id, name: id, initializer: id,
                          a: number, b: number)
variable_declarator(["variable_declarator", A, B], name, nil, A, B) :-
    variable_declarator_id(name, A, B).
variable_declarator(["variable_declarator", A, D], name, initializer, A, D) :-
    variable_declarator_id(name, A, B),
    token_equal_sign(B, C),
    variable_initializer(initializer, C, D).

.decl variable_declarator_id(id: id, a: number, b: number)
variable_declarator_id(id, A, B) :- identifier(id, A, B).
variable_declarator_id(id, A, C) :-
    identifier(id, A, B),
    dims(_, B, C).

.decl variable_initializer(id: id, a: number, b: number)
variable_initializer(id, A, B) :- expression(id, A, B).
variable_initializer(id, A, B) :- array_initializer(id, A, B).

.decl unann_type(id: id, a: number, b: number)
unann_type(id, A, B) :- unann_primitive_type(id, A, B).
unann_type(id, A, B) :- unann_reference_type(id, A, B).

.decl unann_primitive_type(id: id, a: number, b: number)
unann_primitive_type(["boolean_type", A, B], A, B) :- token_boolean(A, B).
unann_primitive_type(e, A, B) :- numeric_type(e, A, B).

.decl unann_reference_type(id: id, a: number, b: number)
unann_reference_type(id, A, B) :- unann_class_or_interface_type(id, A, B).
unann_reference_type(id, A, B) :- unann_array_type(id, A, B).
// Note: the derivation of UnannTypeVariable is omitted to handle an ambiguity
// in the Java specification. The same derivation is handled by
// UnannClassOrInterfaceType → UnannClassType -> TypeIdentifier

.decl unann_class_or_interface_type(id: id, a: number, b: number)
unann_class_or_interface_type(id, A, B) :- unann_class_type(id, A, B).
unann_class_or_interface_type(id, A, B) :- unann_interface_type(id, A, B).

.decl unann_class_type(id: id, a: number, b: number)
unann_class_type(nil, A, C) :-
    type_identifier(_, A, B),
    type_arguments?(_, B, C).
unann_class_type(nil, A, F) :-
    package_name(_, A, B),
    token_dot(B, C),
    annotations?(_, C, D),
    type_identifier(_, D, E),
    type_arguments?(_, E, F).
unann_class_type(nil, A, F) :-
    unann_class_or_interface_type(_, A, B),
    token_dot(B, C),
    annotations?(_, C, D),
    type_identifier(_, D, E),
    type_arguments?(_, E, F).

.decl unann_interface_type(id: id, a: number, b: number)
unann_interface_type(id, A, B) :- unann_class_type(id, A, B).

.decl unann_type_variable(id: id, a: number, b: number)
unann_type_variable(["type_variable", A, B], A, B) :-
    type_identifier(_, A, B).

.decl unann_array_type(id: id, a: number, b: number)
unann_array_type(["array_type", A, C], A, C) :-
    primitive_type(_, A, B),
    dims(_, B, C).
unann_array_type(["array_type", A, C], A, C) :-
    unann_class_or_interface_type(_, A, B),
    dims(_, B, C).
// Note: the derivation of UnannTypeVariable is omitted to handle an ambiguity
// in the Java specification. The same derivation is handled by
// UnannClassOrInterfaceType → UnannClassType -> TypeIdentifier

.decl method_declaration(id: id, mods: id_list, header: id,
                         body: id, a: number, b: number)
method_declaration(["method_declaration", A, D], mods, header, body, A, D) :-
    method_modifiers?(mods, A, B),
    method_header(header, _, _, B, C),
    method_body(body, C, D).

.decl method_modifiers?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(method_modifiers?, method_modifier)

.decl method_modifier(id: id, a: number, b: number)
method_modifier(["public_modifier", A, B], A, B) :- token_public(A, B).
method_modifier(["protected_modifier", A, B], A, B) :- token_protected(A, B).
method_modifier(["private_modifier", A, B], A, B) :- token_private(A, B).
method_modifier(["abstract_modifier", A, B], A, B) :- token_abstract(A, B).
method_modifier(["static_modifier", A, B], A, B) :- token_static(A, B).
method_modifier(["final_modifier", A, B], A, B) :- token_final(A, B).
method_modifier(["synchronized_modifier", A, B], A, B) :-
    token_synchronized(A, B).
method_modifier(["native_modifier", A, B], A, B) :- token_native(A, B).
method_modifier(["strictfp_modifier", A, B], A, B) :- token_strictfp(A, B).

.decl method_header(id: id, res: id, decl: id, a: number, b: number)
method_header(["method_header", A, D], res, decl, A, D) :-
    result(res, A, B),
    method_declarator(decl, _, _, B, C),
    throws?(_, C, D).

.decl result(id: id, a: number, b: number)
result(t, A, B) :- unann_type(t, A, B).
result(["void_type", A, B], A, B) :- token_void(A, B).

.decl method_declarator(id: id, name: id, params: id_list, a: number, b: number)
method_declarator(["method_declarator", A, H], name, params, A, H) :-
    identifier(name, A, B),
    token_left_paren(B, C),
    receiver_parameter(_, C, D),
    token_comma(D, E),
    formal_parameter_list?(params, E, F),
    token_right_paren(F, G),
    dims?(_, G, H).
method_declarator(["method_declarator", A, F], name, params, A, F) :-
    identifier(name, A, B),
    token_left_paren(B, C),
    formal_parameter_list?(params, C, D),
    token_right_paren(D, E),
    dims?(_, E, F).

.decl receiver_parameter(id: id, a: number, b: number)
receiver_parameter(["receiver_parameter", A, F], A, F) :-
    annotations?(nil, A, B),
    unann_type(_, B, C),
    identifier(_, C, D),
    token_dot(D, E),
    token_this(E, F).
receiver_parameter(["receiver_parameter", A, D], A, D) :-
    annotations?(_, A, B),
    unann_type(_, B, C),
    token_this(C, D).

.decl formal_parameter_list(ids: id_list, a: number, b: number)
formal_parameter_list([x, nil], A, B) :- formal_parameter(x, A, B).
formal_parameter_list([x, xs], A, D) :-
    formal_parameter(x, A, B),
    token_comma(B, C),
    formal_parameter_list(xs, C, D).

.decl formal_parameter_list?(ids: id_list, a: number, b: number)
formal_parameter_list?(nil, A, A) :- any_position(A).
formal_parameter_list?(x, A, B) :- formal_parameter_list(x, A, B).

.decl formal_parameter(id: id, a: number, b: number)
formal_parameter(nil, A, D) :-
    variable_modifiers?(_, A, B),
    unann_type(_, B, C),
    variable_declarator_id(_, C, D).
formal_parameter(id, A, B) :- variable_arity_parameter(id, A, B).

.decl variable_arity_parameter(id: id, a: number, b: number)
variable_arity_parameter(nil, A, F) :-
    variable_modifiers?(_, A, B),
    unann_type(_, B, C),
    annotations?(_, C, D),
    token_ellipsis(D, E),
    identifier(_, E, F).

.decl variable_modifier(id: id, a: number, b: number)
variable_modifier(["annotation_modifier", A, B], A, B) :- annotation(a, A, B).
variable_modifier(["final_modifier", A, B], A, B) :- token_final(A, B).

.decl variable_modifiers?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(variable_modifiers?, variable_modifier)

.decl throws(ids: id_list, a: number, b: number)
throws(ids, A, C) :-
    token_throws(A, B),
    exception_type_list(ids, B, C).

.decl throws?(ids: id_list, a: number, b: number)
throws?(nil, A, A) :- any_position(A).
throws?(x,   A, B) :- throws(x, A, B).

.decl exception_type_list(ids: id_list, a: number, b: number)
exception_type_list([x, nil], A, B) :- exception_type(x, A, B).
exception_type_list([x, xs], A, D) :-
    exception_type(x, A, B),
    token_comma(B, C),
    exception_type_list(xs, C, D).

.decl exception_type(id: id, a: number, b: number)
exception_type(id, A, B) :- class_type(id, A, B).
// Note: the derivation of TypeVariable is omitted to handle an ambiguity in
// the Java specification. The same derivation is handled by
// ClassType → {Annotation} TypeIdentifier

.decl method_body(id: id, a: number, b: number)
method_body(id, A, B) :-
    block(id, _, A, B).
method_body(nil, A, B) :-
    token_semicolon(A, B).

.decl instance_initializer(id: id, a: number, b: number)
instance_initializer(["instance_initializer", A, B], A, B)
    :- block(_, _, A, B).

.decl static_initializer(id: id, a: number, b: number)
static_initializer(["static_initializer", A, C], A, C) :-
    token_static(A, B),
    block(_, _, B, C).

.decl constructor_declaration(id: id, a: number, b: number)

.decl constructor_modifier(id: id, a: number, b: number)
constructor_modifier(["annotation_modifier", A, B], A, B) :-
    annotation(a, A, B).
constructor_modifier(["public_modifier", A, B], A, B) :- token_public(A, B).
constructor_modifier(["protected_modifier", A, B], A, B) :-
    token_protected(A, B).
constructor_modifier(["private_modifier", A, B], A, B) :- token_private(A, B).

.decl constructor_declarator(id: id, a: number, b: number)

.decl simple_type_name(id: id, l: number, n: number)
simple_type_name(["simple_type_name", A, B], A, B) :- type_identifier(_, A, B).

.decl constructor_body(id: id, a: number, b: number)

.decl explicit_constructor_invocation(id: id, a: number, b: number)

.decl enum_declaration(id: id, a: number, b: number)

.decl enum_body(id: id, a: number, b: number)
enum_body(nil, A, F) :-
    token_left_curly_bracket(A, B),
    enum_constant_list?(_, B, C),
    token_comma?(C, D),
    enum_body_declarations?(_, D, E),
    token_right_curly_bracket(E, F).

.decl enum_constant_list(id: id_list, a: number, b: number)
enum_constant_list([x, nil], A, B) :- enum_constant(x, A, B).
enum_constant_list([x, xs], A, D) :-
    enum_constant(x, A, B),
    token_comma(B, C),
    enum_constant_list(xs, C, D).

.decl enum_constant_list?(id: id_list, a: number, b: number)
enum_constant_list?(nil, A, A) :- any_position(A).
enum_constant_list?(x, A, B) :- enum_constant_list(x, A, B).

.decl enum_constant(id: id, a: number, b: number)
enum_constant(nil, A, D) :-
    enum_constant_modifiers?(_, A, B),
    identifier(_, B, C),
    class_body?(_, C, D).
//enum_constant($EnumConstant(mods, id, args, nil), A, G) :-
//    enum_constant_modifiers?(mods, A, B),
//    identifier(id, B, C),
//    token_left_paren(C, D),
//    argument_list?(args, D, E),
//    token_right_paren(E, F),
//    class_body?(_, F, G).

.decl enum_constant_modifier(id: id, a: number, b: number)
enum_constant_modifier(["annotation_modifier", A, B], A, B) :-
    annotation(a, A, B).

.decl enum_constant_modifiers?(id: id_list, a: number, b: number)
ZERO_OR_MORE(enum_constant_modifiers?, enum_constant_modifier)

.decl enum_body_declarations(ids: id_list, a: number, b: number)
enum_body_declarations(ids, A, C) :-
    token_semicolon(A, B),
    class_body_declarations?(ids, B, C).

.decl enum_body_declarations?(e: id_list, a: number, b: number)
enum_body_declarations?(nil, A, A) :- any_position(A).
enum_body_declarations?(ids, A, B) :- enum_body_declarations(ids, A, B).

/**
 * Interfaces
 * See §9 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl interface_declaration(id: id, a: number, b: number)
interface_declaration(id, A, B) :- normal_interface_declaration(id, A, B).
interface_declaration(id, A, B) :- annotation_type_declaration(id, A, B).

.decl normal_interface_declaration(id: id, a: number, b: number)

.decl interface_modifier(id: id, a: number, b: number)
interface_modifier(["public_modifier", A, B], A, B) :- token_public(A, B).
interface_modifier(["protected_modifier", A, B], A, B) :- token_protected(A, B).
interface_modifier(["private_modifier", A, B], A, B) :- token_private(A, B).
interface_modifier(["abstract_modifier", A, B], A, B) :- token_abstract(A, B).
interface_modifier(["static_modifier", A, B], A, B) :- token_static(A, B).
interface_modifier(["strictfp_modifier", A, B], A, B) :- token_strictfp(A, B).

.decl interface_modifiers?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(interface_modifiers?, interface_modifier)

.decl extends_interfaces(a: number, b: number)

.decl interface_body(a: number, b: number)

.decl interface_member_declaration(a: number, b: number)

.decl constant_declaration(id: id, a: number, b: number)

.decl constant_modifier(id: id, a: number, b: number)
constant_modifier(["annotation_modifier", A, B], A, B) :- annotation(_, A, B).
constant_modifier(["public_modifier", A, B], A, B) :- token_public(A, B).
constant_modifier(["static_modifier", A, B], A, B) :- token_static(A, B).
constant_modifier(["final_modifier", A, B], A, B) :- token_final(A, B).

.decl interface_method_declaration(a: number, b: number)

.decl interface_method_modifier(id: id, a: number, b: number)
interface_method_modifier(["annotation_modifier", A, B], A, B) :-
    annotation(_, A, B).
interface_method_modifier(["public_modifier", A, B], A, B) :-
    token_public(A, B).
interface_method_modifier(["private_modifier", A, B], A, B) :-
    token_private(A, B).
interface_method_modifier(["abstract_modifier", A, B], A, B) :-
    token_abstract(A, B).
interface_method_modifier(["default_modifier", A, B], A, B) :-
    token_default(A, B).
interface_method_modifier(["static_modifier", A, B], A, B) :-
    token_static(A, B).
interface_method_modifier(["strictfp_modifier", A, B], A, B) :-
    token_strictfp(A, B).

.decl annotation_type_declaration(id: id, a: number, b: number)
annotation_type_declaration(["annotation_type_declaration", A, F], A, F) :-
    interface_modifiers?(_, A, B),
    token_at(B, C),
    token_interface(C, D),
    type_identifier(_, D, E),
    annotation_type_body(_, E, F).

.decl annotation_type_body(ids: id_list, a: number, b: number)
annotation_type_body(decls, A, D) :-
    token_left_curly_bracket(A, B),
    annotation_type_member_declarations?(decls, B, C),
    token_right_curly_bracket(C, D).

.decl annotation_type_member_declaration(id: id, a: number, b: number)
annotation_type_member_declaration(d, A, B) :-
    annotation_type_element_declaration(d, A, B).
annotation_type_member_declaration(d, A, B) :- constant_declaration(d, A, B).
annotation_type_member_declaration(d, A, B) :- class_declaration(d, A, B).
annotation_type_member_declaration(d, A, B) :- interface_declaration(d, A, B).
annotation_type_member_declaration(nil, A, B) :- token_semicolon(A, B).

.decl annotation_type_member_declarations?(d: id_list, a: number, b: number)
ZERO_OR_MORE(annotation_type_member_declarations?,
             annotation_type_member_declaration)


.decl annotation_type_element_declaration(id: id, a: number, b: number)

.decl annotation_type_element_modifier(id: id, a: number, b: number)
annotation_type_element_modifier(["public_modifier", A, B], A, B) :-
    token_public(A, B).
annotation_type_element_modifier(["abstract_modifier", A, B], A, B) :-
    token_abstract(A, B).

.decl annotation_type_element_modifiers?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(annotation_type_element_modifiers?,
             annotation_type_element_modifier)

.decl default_value(id: id, a: number, b: number)
default_value(e, A, C) :-
    token_default(A, B),
    element_value(e, B, C).

.decl annotation(id: id, a: number, b: number)
annotation(e, A, B) :- normal_annotation(e, A, B).

.decl annotations?(id: id_list, a: number, b: number)
ZERO_OR_MORE(annotations?, annotation)

.decl normal_annotation(id: id, a: number, b: number)
normal_annotation(nil, A, F) :-
    token_at(A, B),
    type_name(_, B, C),
    token_left_paren(C, D),
    element_value_pair_list?(_, D, E),
    token_right_paren(E, F).

.decl element_value_pair_list(id: id_list, a: number, b: number)
element_value_pair_list([x, nil], A, B) :- element_value_pair(x, A, B).
element_value_pair_list([x, xs], A, D) :-
    element_value_pair(x, A, B),
    token_comma(B, C),
    element_value_pair_list(xs, C, D).

.decl element_value_pair_list?(id: id_list, a: number, b: number)
element_value_pair_list?(nil, A, A) :- any_position(A).
element_value_pair_list?(x, A, B) :- element_value_pair_list(x, A, B).

.decl element_value_pair(id: id, a: number, b: number)
element_value_pair(nil, A, D) :-
    identifier(_, A, B),
    token_equal_sign(B, C),
    element_value(_, C, D).

.decl element_value(id: id, a: number, b: number)

.decl element_value_array_initializer(ids: id_list, a: number, b: number)
element_value_array_initializer(e, A, E) :-
    token_left_curly_bracket(A, B),
    element_value_list?(e, B, C),
    token_comma?(C, D),
    token_right_curly_bracket(D, E).

.decl element_value_list(ids: id_list, a: number, b: number)
element_value_list([x, nil], A, B) :- element_value(x, A, B).
element_value_list([x, xs], A, D) :-
    element_value(x, A, B),
    token_comma(B, C),
    element_value_list(xs, C, D).

.decl element_value_list?(ids: id_list, a: number, b: number)
element_value_list?(nil, A, A) :- any_position(A).
element_value_list?(x, A, B) :- element_value_list(x, A, B).

.decl marker_annotation(id: id, a: number, b: number)
marker_annotation(e, A, C) :-
    token_at(A, B),
    type_name(e, B, C).

// TODO SingleElementAnnotation

/**
 * Arrays
 * See §10 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl array_initializer(id: id, a: number, b: number)
array_initializer(["array_initializer_expression", A, E], A, E) :- 
    token_left_curly_bracket(A, B),
    variable_initializer_list?(_, B, C),
    token_comma?(C, D),
    token_right_curly_bracket(D, E).

.decl variable_initializer_list(ids: id_list, a: number, b: number)
variable_initializer_list([x, nil], A, B) :- variable_initializer(x, A, B).
variable_initializer_list([x, xs], A, D) :-
    variable_initializer(x, A, B),
    token_comma(B, C),
    variable_initializer_list(xs, C, D).

.decl variable_initializer_list?(ids: id_list, a: number, b: number)
variable_initializer_list?(nil, A, A) :- any_position(A).
variable_initializer_list?(x, A, B) :- variable_initializer_list(x, A, B).

/**
 * Blocks and Statements
 * See §14 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl block(id: id, statements: id_list, a: number, b: number)
block(["block", A, D], statements, A, D) :-
    token_left_curly_bracket(A, B),
    block_statements?(statements, B, C),
    token_right_curly_bracket(C, D).

.decl block_statements?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(block_statements?, block_statement)

.decl block_statement(id: id, a: number, b: number)
block_statement(id, A, B) :- local_variable_declaration_statement(id, A, B).
// TODO: class declaration
block_statement(id, A, B) :- statement(id, A, B).

.decl local_variable_declaration_statement(id: id, a: number, b: number)
local_variable_declaration_statement(id, A, C) :-
    local_variable_declaration(id, _, _, _, A, B),
    token_semicolon(B, C).

.decl local_variable_declaration(id: id, mods: id_list, type: id,
                                 declarators: id_list, a: number, b: number)
local_variable_declaration(["local_variable_declaration", A, D], mods, type,
                           declarators, A, D) :-
    variable_modifiers?(mods, A, B),
    local_variable_type(type, B, C),
    variable_declarator_list(declarators, C, D).

.decl local_variable_type(id: id, a: number, b: number)
local_variable_type(id, A, B) :- unann_type(id, A, B).
local_variable_type(["var_type", A, B], A, B) :- token_var(A, B).

.decl statement(id: id, a: number, b: number)
statement(id, A, B) :- statement_without_trailing_substatement(id, A, B).
statement(id, A, B) :- labeled_statement(id, A, B).
statement(id, A, B) :- if_then_statement(id, _, _, A, B).
statement(id, A, B) :- if_then_else_statement(id, A, B).
statement(id, A, B) :- while_statement(id, A, B).
statement(id, A, B) :- for_statement(id, A, B).

.decl statement_no_short_if(id: id, a: number, b: number)
statement_no_short_if(id, A, B) :-
    statement_without_trailing_substatement(id, A, B).
statement_no_short_if(id, A, B) :- labeled_statement_no_short_if(id, A, B).
statement_no_short_if(id, A, B) :- if_then_else_statement_no_short_if(id, A, B).
statement_no_short_if(id, A, B) :- while_statement_no_short_if(id, A, B).
statement_no_short_if(id, A, B) :- for_statement_no_short_if(id, A, B).

.decl statement_without_trailing_substatement(id: id, a: number, b: number)
statement_without_trailing_substatement(id, A, B) :- block(id, _, A, B).
statement_without_trailing_substatement(id, A, B) :- empty_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :-
    expression_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :- assert_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :- switch_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :- do_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :- break_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :-
    continue_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :- return_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :-
    synchronized_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :- throw_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :- try_statement(id, A, B).
statement_without_trailing_substatement(id, A, B) :- yield_statement(id, A, B).

.decl empty_statement(id: id, a: number, b: number)
empty_statement(["empty_statement", A, B], A, B) :- token_semicolon(A, B).

.decl labeled_statement(id: id, a: number, b: number)
labeled_statement(["labeled_statement", A, D], A, D) :-
    token_identifier(_, A, B),
    token_colon(B, C),
    statement(_, C, D).

.decl labeled_statement_no_short_if(id: id, a: number, b: number)
labeled_statement_no_short_if(["labeled_statement", A, D], A, D) :-
    token_identifier(_, A, B),
    token_colon(B, C),
    statement_no_short_if(_, C, D).

.decl expression_statement(id: id, a: number, b: number)
expression_statement(id, A, C) :-
    statement_expression(id, A, B),
    token_semicolon(B, C).

.decl statement_expression(id: id, a: number, b: number)
statement_expression(id, A, B) :- assignment(id, A, B).
statement_expression(id, A, B) :- pre_increment_expression(id, A, B).
statement_expression(id, A, B) :- pre_decrement_expression(id, A, B).
statement_expression(id, A, B) :- post_increment_expression(id, A, B).
statement_expression(id, A, B) :- post_decrement_expression(id, A, B).
statement_expression(id, A, B) :- method_invocation(id, _, A, B).
statement_expression(id, A, B) :- class_instance_creation_expression(id, A, B).

.decl if_then_statement(id: id, expr: id, statement: id, a: number, b: number)
if_then_statement(["if_then_statement", A, F], expr, statement, A, F) :-
    token_if(A, B),
    token_left_paren(B, C),
    expression(expr, C, D),
    token_right_paren(D, E),
    statement(statement, E, F).

.decl if_then_else_statement(id: id, a: number, b: number)
if_then_else_statement(["if_then_else_statement", A, H], A, H) :-
    token_if(A, B),
    token_left_paren(B, C),
    expression(_, C, D),
    token_right_paren(D, E),
    statement_no_short_if(_, E, F),
    token_else(F, G),
    statement(_, G, H).

.decl if_then_else_statement_no_short_if(id: id, a: number, b: number)
if_then_else_statement_no_short_if(["if_then_else_statement", A, H], A, H) :-
    token_if(A, B),
    token_left_paren(B, C),
    expression(_, C, D),
    token_right_paren(D, E),
    statement_no_short_if(_, E, F),
    token_else(F, G),
    statement_no_short_if(_, G, H).

.decl assert_statement(id: id, a: number, b: number)
assert_statement(["assert_statement", A, D], A, D) :-
    token_assert(A, B),
    expression(_, B, C),
    token_semicolon(C, D).
assert_statement(["assert_statement", A, F], A, F) :-
    token_assert(A, B),
    expression(_, B, C),
    token_colon(C, D),
    expression(_, D, E),
    token_semicolon(E, F).

.decl switch_statement(id: id, a: number, b: number)
switch_statement(["switch_statement", A, F], A, F) :-
    token_switch(A, B),
    token_left_paren(B, C),
    expression(_, C, D),
    token_right_paren(D, E),
    switch_block(_, E, F).

.decl switch_block(ids: id_list, a: number, b: number)
switch_block([rule, rules], A, E) :-
    token_left_curly_bracket(A, B),
    switch_rule(rule, B, C),
    switch_rules?(rules, C, D),
    token_right_curly_bracket(D, E).

.decl switch_rules?(ids: id_list, a: number, b: number)
ZERO_OR_MORE(switch_rules?, switch_rule)

.decl switch_rule(id: id, a: number, b: number)
//switch_rule($SwitchRuleExpr(label, expr), A, E) :-
//    switch_label(label, A, B),
//    token_arrow(B, C),
//    expression(expr, C, D),
//    token_semicolon(D, E).
//switch_rule($SwitchRuleBlock(label, stmt), A, D) :-
//    switch_label(label, A, B),
//    token_arrow(B, C),
//    block(stmt, C, D).
//switch_rule($SwitchRuleBlock(label, stmt), A, D) :-
//    switch_label(label, A, B),
//    token_arrow(B, C),
//    throw_statement(stmt, C, D).

.decl switch_block_statement_group(a: number, b: number)

.decl switch_label(id: id, a: number, b: number)
//switch_label($SwitchDefault, A, B) :- token_default(A, B).
//switch_label($SwitchCase(exprs), A, C) :-
//    token_case(A, B),
//    case_constants(exprs, B, C).

.decl case_constants(ids: id_list, a: number, b: number)
case_constants([x, nil], A, B) :- case_constant(x, A, B).
case_constants([x, xs], A, D) :-
    case_constant(x, A, B),
    token_comma(B, C),
    case_constants(xs, C, D).

.decl case_constant(id: id, a: number, b: number)
case_constant(id, A, B) :- conditional_expression(id, A, B).

.decl while_statement(id: id, a: number, b: number)
while_statement(["while_statement", A, F], A, F) :-
    token_while(A, B),
    token_left_paren(B, C),
    expression(_, C, D),
    token_right_paren(D, E),
    statement(_, E, F).

.decl while_statement_no_short_if(id: id, a: number, b: number)
while_statement_no_short_if(["while_statement", A, F], A, F) :-
    token_while(A, B),
    token_left_paren(B, C),
    expression(_, C, D),
    token_right_paren(D, E),
    statement_no_short_if(_, E, F).

.decl do_statement(id: id, a: number, b: number)
do_statement(["do_statement", A, H], A, H) :-
    token_do(A, B),
    statement(_, B, C),
    token_while(C, D),
    token_left_paren(D, E),
    expression(_, E, F),
    token_right_paren(F, G),
    token_semicolon(G, H).

.decl for_statement(id: id, a: number, b: number)
for_statement(id, A, B) :- for_statement_no_short_if(id, A, B).
for_statement(id, A, B) :- enhanced_for_statement(id, A, B).

.decl for_statement_no_short_if(id: id, a: number, b: number)
for_statement_no_short_if(id, A, B) :-
    basic_for_statement_no_short_if(id, A, B).
for_statement_no_short_if(id, A, B) :-
    enhanced_for_statement_no_short_if(id, A, B).

.decl basic_for_statement(id: id, a: number, b: number)
basic_for_statement(["for_statement", A, J], A, J) :-
    token_for(A, B),
    token_left_paren(B, C),
    for_init?(_, C, D),
    token_semicolon(D, E),
    expression?(_, E, F),
    token_semicolon(F, G),
    for_update?(_, G, H),
    token_right_paren(H, I),
    statement(_, I, J).

.decl basic_for_statement_no_short_if(id: id, a: number, b: number)
basic_for_statement(["for_statement", A, J], A, J) :-
    token_for(A, B),
    token_left_paren(B, C),
    for_init?(_, C, D),
    token_semicolon(D, E),
    expression?(_, E, F),
    token_semicolon(F, G),
    for_update?(_, G, H),
    token_right_paren(H, I),
    statement_no_short_if(_, I, J).

.decl for_init(id: id, a: number, b: number)
for_init(["for_init", A, B], A, B) :- statement_expression_list(_, A, B).
for_init(["for_init", A, B], A, B) :- local_variable_declaration(_, _, _, _, A, B).

.decl for_init?(id: id, a: number, b: number)
ID_OPTIONAL(for_init?, for_init)

.decl for_update(ids: id_list, a: number, b: number)
for_update(ids, A, B) :- statement_expression_list(ids, A, B).

.decl for_update?(ids: id_list, a: number, b: number)
ID_OPTIONAL(for_update?, for_update)

.decl statement_expression_list(id: id_list, a: number, b: number)
statement_expression_list([x, nil], A, B) :- statement_expression(x, A, B).
statement_expression_list([x, xs], A, D) :-
    statement_expression(x, A, B),
    token_comma(B, C),
    statement_expression_list(xs, C, D).
// FIXME

.decl enhanced_for_statement(id: id, a: number, b: number)

.decl enhanced_for_statement_no_short_if(id: id, a: number, b: number)

.decl break_statement(id: id, a: number, b: number)
break_statement(["break_statement", A, D], A, D) :-
    token_break(A, B),
    identifier?(id, B, C),
    token_semicolon(C, D).

.decl yield_statement(id: id, a: number, b: number)
yield_statement(["yield_statement", A, D], A, D) :-
    token_yield(A, B),
    expression(_, B, C),
    token_semicolon(C, D).

.decl continue_statement(id: id, a: number, b: number)
continue_statement(["continue_statement", A, D], A, D) :-
    token_continue(A, B),
    identifier?(_, B, C),
    token_semicolon(C, D).

.decl return_statement(id: id, a: number, b: number)
return_statement(["return_statement", A, D], A, D) :-
    token_return(A, B),
    expression?(_, B, C),
    token_semicolon(C, D).

.decl throw_statement(id: id, a: number, b: number)
throw_statement(["throw_statement", A, D], A, D) :-
    token_throw(A, B),
    expression(_, B, C),
    token_semicolon(C, D).

.decl synchronized_statement(id: id, a: number, b: number)
//synchronized_statement($SynchronizedStatement(e, s), A, F) :-
//    token_synchronized(A, B),
//    token_left_paren(B, C),
//    expression(e, C, D),
//    token_right_paren(D, E),
//    block(s, E, F).

.decl try_statement(id: id, a: number, b: number)
//try_statement($TryStatement(s, c), A, D) :-
//    token_try(A, B),
//    block(s, B, C),
//    catches(c, C, D).
// TODO ...

.decl catches(ids: id_list, a: number, b: number)
catches([x, nil], A, B) :- catch_clause(x, A, B).
catches([x, xs], A, C) :-
    catch_clause(x, A, B),
    catches(xs, B, C).

.decl catch_clause(id: id, a: number, b: number)
//catch_clause($CatchClause(param, b), A, F) :-
//    token_catch(A, B),
//    token_left_paren(B, C),
//    catch_formal_parameter(param, C, D),
//    token_right_paren(D, E),
//    block(b, E, F).

.decl catch_formal_parameter(id: id, a: number, b: number)
catch_formal_parameter(nil, A, D) :-
    variable_modifiers?(_, A, B),
    catch_type(_, B, C),
    variable_declarator_id(_, C, D).

.decl catch_type(ids: id_list, a: number, b: number)
catch_type([x, nil], A, B) :- unann_class_type(x, A, B).
catch_type([x, xs], A, C) :-
    unann_class_type(x, A, B),
    catch_type_tail(xs, B, C).

.decl catch_type_tail(ids: id_list, a: number, b: number)
catch_type_tail(nil, A, A) :- any_position(A).
catch_type_tail([x, xs], A, D) :-
    token_vertical_bar(A, B),
    class_type(x, B, C),
    catch_type_tail(xs, C, D).

.decl finally(id: id, a: number, b: number)
//finally(b, A, C) :-
//    token_finally(A, B),
//    block(b, B, C).

// TODO TryWithResourcesStatement

// TODO ResourceSpecification
.decl resource_specification(ids: id_list, a: number, b: number)
resource_specification(e, A, E) :-
    token_left_paren(A, B),
    resource_list(e, B, C),
    token_semicolon?(C, D),
    token_right_paren(D, E).

.decl resource_list(ids: id_list, a: number, b: number)
resource_list([x, nil], A, B) :- resource(x, A, B).
resource_list([x, xs], A, D) :-
    resource(x, A, B),
    token_semicolon(B, C),
    resource_list(xs, C, D).

.decl resource(id: id, a: number, b: number)
//resource($ResourceInitialization(mods, type, id, expr), A, F) :-
//    variable_modifiers?(mods, A, B),
//    local_variable_type(type, B, C),
//    identifier(id, C, D),
//    token_equal_sign(D, E),
//    expression(expr, E, F).
//resource($ResourceAccess(e), A, B) :-
//    variable_access(e, A, B).

.decl variable_access(id: id, a: number, b: number)

/**
 * Expressions
 * See §15 of https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

.decl primary(id: id, a: number, b: number)
primary(id, A, B) :- primary_no_new_array(id, A, B).
primary(id, A, B) :- array_creation_expression(id, A, B).

.decl primary_no_new_array(id: id, a: number, b: number)
primary_no_new_array(id, A, B) :- literal(id, A, B).
primary_no_new_array(id, A, B) :- class_literal(id, A, B).
primary_no_new_array(["this_expression", A, B], A, B) :- token_this(A, B).
primary_no_new_array(id, A, D) :-
    token_left_paren(A, B),
    expression(id, B, C),
    token_right_paren(C, D).
primary_no_new_array(id, A, B) :- class_instance_creation_expression(id, A, B).
primary_no_new_array(id, A, B) :- field_access(id, A, B).
primary_no_new_array(id, A, B) :- array_access(id, A, B).
primary_no_new_array(id, A, B) :- method_invocation(id, _, A, B).
primary_no_new_array(id, A, B) :- method_reference(id, A, B).

.decl class_literal(id: id, a: number, b: number)

.decl class_instance_creation_expression(id: id, a: number, b: number)
class_instance_creation_expression(id, A, B) :-
    unqualified_class_instance_creation_expression(id, _, A, B).
// TODO ...

.decl unqualified_class_instance_creation_expression(id: id,
                                                     args: id,
                                                     a: number, b: number)
unqualified_class_instance_creation_expression(["unqualified_class_instance_creation_expression", A, H], args, A, H) :-
    token_new(A, B),
    type_arguments?(_, B, C),
    class_or_interface_type_to_instantiate(_, C, D),
    token_left_paren(D, E),
    argument_list?(args, E, F),
    token_right_paren(F, G),
    class_body?(_, G, H).

.decl class_or_interface_type_to_instantiate(id: id, a: number, b: number)
class_or_interface_type_to_instantiate(nil, A, D) :-
    annotations?(_, A, B),
    identifier(_, B, C),
    // TODO ...
    type_arguments_or_diamond(_, C, D).

.decl type_arguments_or_diamond(ids: id_list, a: number, b: number)
type_arguments_or_diamond(nil, A, C) :-
    token_less_than(A, B),
    token_greater_than(B, C).
type_arguments_or_diamond(t, A, B) :- type_arguments(t, A, B).

.decl field_access(id: id, a: number, b: number)
field_access(nil, A, D) :-
    primary(_, A, B),
    token_dot(B, C),
    identifier(_, C, D).
// TODO ...

.decl array_access(id: id, a: number, b: number)
array_access(nil, A, E) :-
    expression_name(_, A, B),
    token_left_square_bracket(B, C),
    expression(_, C, D),
    token_right_square_bracket(D, E).
array_access(nil, A, E) :-
    primary_no_new_array(_, A, B),
    token_left_square_bracket(B, C),
    expression(_, C, D),
    token_right_square_bracket(D, E).

.decl method_invocation(id: id, arguments: id, a: number, b: number)
method_invocation(["method_invocation", A, E], args, A, E) :-
    method_name(_, A, B),
    token_left_paren(B, C),
    argument_list?(args, C, D),
    token_right_paren(D, E).
method_invocation(["method_invocation", A, H], args, A, H) :-
    type_name(_, A, B),
    token_dot(B, C),
    type_arguments?(_, C, D),
    identifier(_, D, E),
    token_left_paren(E, F),
    argument_list?(args, F, G),
    token_right_paren(G, H).
method_invocation(["method_invocation", A, H], args, A, H) :-
    expression_name(_, A, B),
    token_dot(B, C),
    type_arguments?(_, C, D),
    identifier(_, D, E),
    token_left_paren(E, F),
    argument_list?(args, F, G),
    token_right_paren(G, H).
method_invocation(["method_invocation", A, H], args, A, H) :-
    primary(_, A, B),
    token_dot(B, C),
    type_arguments?(_, C, D),
    identifier(_, D, E),
    token_left_paren(E, F),
    argument_list?(args, F, G),
    token_right_paren(G, H).
method_invocation(["method_invocation", A, H], args, A, H) :-
    token_super(A, B),
    token_dot(B, C),
    type_arguments?(_, C, D),
    identifier(_, D, E),
    token_left_paren(E, F),
    argument_list?(args, F, G),
    token_right_paren(G, H).
method_invocation(["method_invocation", A, H], args, A, J) :-
    type_name(_, A, B),
    token_dot(B, C),
    token_super(C, D),
    token_dot(D, E),
    type_arguments?(_, E, F),
    identifier(_, F, G),
    token_left_paren(G, H),
    argument_list?(args, H, I),
    token_right_paren(I, J).

.decl argument_list?(id: id, a: number, b: number)
argument_list?(nil, A, A) :- any_position(A).
argument_list?(id, A, B) :- argument_list(id, _, A, B).

.decl argument_list(id: id, children: id_list, a: number, b: number)
argument_list(["argument_list", A, B], [x, nil], A, B) :- expression(x, A, B).
argument_list(["argument_list", A, D], [x, xs], A, D) :-
    expression(x, A, B),
    token_comma(B, C),
    argument_list(_, xs, C, D).

.decl method_reference(id: id, a: number, b: number)
method_reference(["method_reference", A, F], A, F) :-
    expression_name(_, A, B),
    token_colon(B, C),
    token_colon(C, D),
    type_arguments?(_, D, E),
    identifier(_, E, F).
method_reference(["method_reference", A, F], A, F) :-
    primary(_, A, B),
    token_colon(B, C),
    token_colon(C, D),
    type_arguments?(_, D, E),
    identifier(_, E, F).
method_reference(["method_reference", A, F], A, F) :-
    reference_type(_, A, B),
    token_colon(B, C),
    token_colon(C, D),
    type_arguments?(_, D, E),
    identifier(_, E, F).
// TODO ...

.decl array_creation_expression(id: id, a: number, b: number)
array_creation_expression(["array_creation_expression", A, E], A, E) :-
    token_new(A, B),
    primitive_type(_, B, C),
    dim_exprs(_, C, D),
    dims?(_, D, E).
array_creation_expression(["array_creation_expression", A, E], A, E) :-
    token_new(A, B),
    class_or_interface_type(_, B, C),
    dim_exprs(_, C, D),
    dims?(_, D, E).
array_creation_expression(["array_creation_expression", A, E], A, E) :-
    token_new(A, B),
    primitive_type(_, B, C),
    dims(_, C, D),
    array_initializer(_, D, E).
array_creation_expression(["array_creation_expression", A, E], A, E) :-
    token_new(A, B),
    class_or_interface_type(_, B, C),
    dims(_, C, D),
    array_initializer(_, D, E).

.decl dim_exprs(ids: id_list, a: number, b: number)
dim_exprs([x, nil], A, B) :- dim_expr(x, A, B).
dim_exprs([x, xs], A, C) :-
    dim_expr(x, A, B),
    dim_exprs(xs, B, C).

.decl dim_expr(id: id, a: number, b: number)
dim_expr(nil, A, E) :-
    annotations?(_, A, B),
    token_left_square_bracket(B, C),
    expression(_, C, D),
    token_right_square_bracket(D, E).

.decl expression(id: id, a: number, b: number)
expression(id, A, B) :- lambda_expression(id, A, B).
expression(id, A, B) :- assignment_expression(id, A, B).

.decl expression?(id: id, a: number, b: number)
ID_OPTIONAL(expression?, expression)

.decl lambda_expression(id: id, a: number, b: number)
lambda_expression(["lambda_expression", A, D], A, D) :-
    lambda_parameters(_, A, B),
    token_arrow(B, C),
    lambda_body(_, C, D).

.decl lambda_parameters(id: id, a: number, b: number)
lambda_parameters(nil, A, B) :-
    identifier(_, A, B).
lambda_parameters(nil, A, D) :-
    token_left_paren(A, B),
    lambda_parameter_list_first_option(_, B, C),
    token_right_paren(C, D).
lambda_parameters(nil, A, D) :-
    token_left_paren(A, B),
    lambda_parameter_list_second_option(_, B, C),
    token_right_paren(C, D).

/* Note: Rule lambda_parameter_list is handled by the two following rules */
.decl lambda_parameter_list_first_option(ids: id_list, a: number, b: number)
lambda_parameter_list_first_option([x, nil], A, B) :- identifier(x, A, B).
lambda_parameter_list_first_option([x, xs], A, D) :-
    identifier(x, A, B),
    token_comma(B, C),
    lambda_parameter_list_first_option(xs, C, D).
.decl lambda_parameter_list_second_option(ids: id_list, a: number, b: number)
lambda_parameter_list_second_option([x, nil], A, B) :-
    lambda_parameter(x, A, B).
lambda_parameter_list_second_option([x, xs], A, D) :-
    lambda_parameter(x, A, B),
    token_comma(B, C),
    lambda_parameter_list_second_option(xs, C, D).

.decl lambda_parameter(id: id, a: number, b: number)
lambda_parameter(nil, A, D) :-
    variable_modifiers?(_, A, B),
    lambda_parameter_type(_, B, C),
    variable_declarator_id(_, C, D).
lambda_parameter(nil, A, B) :-
    variable_arity_parameter(_, A, B).

.decl lambda_parameter_type(id: id, a: number, b: number)
lambda_parameter_type(t, A, B) :- unann_type(t, A, B).
lambda_parameter_type(["var_type", A, B], A, B) :- token_var(A, B).

.decl lambda_body(id: id, a: number, b: number)

.decl assignment_expression(id: id, a: number, b: number)
assignment_expression(id, A, B) :- conditional_expression(id, A, B).
assignment_expression(id, A, B) :- assignment(id, A, B).

.decl assignment(id: id, a: number, b: number)
assignment(nil, A, D) :-
    left_hand_side(_, A, B),
    assignment_operator(_, B, C),
    expression(_, C, D).

.decl left_hand_side(id: id, a: number, b: number)
left_hand_side(nil, A, B) :-
    expression_name(_, A, B).
left_hand_side(id, A, B) :-
    field_access(id, A, B).
left_hand_side(id, A, B) :-
    array_access(id, A, B).

.decl assignment_operator(s: symbol, a: number, b: number)
assignment_operator(s, A, A + 1) :- token(s, A), s = "=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "*=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "/=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "%=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "+=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "-=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "<<=".
assignment_operator(s, A, A + 1) :- token(s, A), s = ">>=".
assignment_operator(s, A, A + 1) :- token(s, A), s = ">>>=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "&=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "^=".
assignment_operator(s, A, A + 1) :- token(s, A), s = "|=".

.decl conditional_expression(id: id, a: number, b: number)
conditional_expression(id, A, B) :- conditional_or_expression(id, A, B).
conditional_expression(nil, A, F) :-
    conditional_or_expression(_, A, B),
    token_question_mark(B, C),
    expression(_, C, D),
    token_colon(D, E),
    conditional_expression(_, E, F).
conditional_expression(nil, A, F) :-
    conditional_or_expression(_, A, B),
    token_question_mark(B, C),
    expression(_, C, D),
    token_colon(D, E),
    lambda_expression(_, E, F).

.decl conditional_or_expression(id: id, a: number, b: number)
conditional_or_expression(id, A, B) :- conditional_and_expression(id, A, B).

INFIX("or_expression",
      or_expression,
      conditional_or_expression,
      conditional_and_expression,
      "||")

.decl conditional_and_expression(id: id, a: number, b: number)
conditional_and_expression(id, A, B) :- inclusive_or_expression(id, A, B).
conditional_and_expression(id, A, B) :-
    conditional_and_expression_impl(id, _, _, A, B).

INFIX("conditional_and_expression",
      conditional_and_expression_impl,
      conditional_and_expression,
      inclusive_or_expression,
      "&&")

.decl inclusive_or_expression(id: id, a: number, b: number)
inclusive_or_expression(id, A, B) :- exclusive_or_expression(id, A, B).
inclusive_or_expression(id, A, B) :-
    bitwise_inclusive_or_expression(id, _, _, A, B).

INFIX("bitwise_inclusive_or_expression",
      bitwise_inclusive_or_expression,
      inclusive_or_expression,
      exclusive_or_expression,
      "|")

.decl exclusive_or_expression(id: id, a: number, b: number)
exclusive_or_expression(id, A, B) :-
    and_expression(id, A, B).
exclusive_or_expression(id, A, B) :-
    bitwise_exclusive_or_expression(id, _, _, A, B).

INFIX("bitwise_exclusive_or_expression",
      bitwise_exclusive_or_expression,
      exclusive_or_expression,
      and_expression,
      "^")

.decl and_expression(id: id, a: number, b: number)
and_expression(id, A, B) :- equality_expression(id, A, B).
and_expression(id, A, B) :- and_expression_impl(id, _, _, A, B).

INFIX("and_expression",
      and_expression_impl,
      and_expression,
      equality_expression,
      "&")

.decl equality_expression(id: id, a: number, b: number)
equality_expression(id, A, B) :- relational_expression(id, A, B).
equality_expression(id, A, B) :- equals_expression(id, _, _, A, B).
equality_expression(id, A, B) :- not_equals_expression(id, _, _, A, B).

INFIX("equals_expression",
      equals_expression,
      equality_expression,
      relational_expression,
      "==")
INFIX("not_equals_expression",
      not_equals_expression,
      equality_expression,
      relational_expression,
      "!=")

.decl relational_expression(id: id, a: number, b: number)
relational_expression(e, A, B) :- shift_expression(e, A, B).

.decl shift_expression(id: id, a: number, b: number)
shift_expression(id, A, B) :- additive_expression(id, A, B).
shift_expression(id, A, B) :- shift_left_expression(id, _, _, A, B).
shift_expression(id, A, B) :- shift_right_expression(id, _, _, A, B).
shift_expression(id, A, B) :- shift_right_unsigned_expression(id, _, _, A, B).

INFIX("shift_left_expression",
      shift_left_expression,
      shift_expression,
      additive_expression,
      "<<")
INFIX("shift_right_expression",
      shift_right_expression,
      shift_expression,
      additive_expression,
      ">>")
INFIX("shift_right_unsigned_expression",
      shift_right_unsigned_expression,
      shift_expression,
      additive_expression,
      ">>>")

.decl additive_expression(id: id, a: number, b: number)
additive_expression(id, A, B) :- multiplicative_expression(id, A, B).
additive_expression(id, A, B) :- addition_expression(id, _, _, A, B).
additive_expression(id, A, B) :- subtraction_expression(id, _, _, A, B).

INFIX("addition_expression",
      addition_expression,
      additive_expression,
      multiplicative_expression,
      "+")
INFIX("subtraction_expression",
      subtraction_expression,
      additive_expression,
      multiplicative_expression,
      "-")

.decl multiplicative_expression(id: id, a: number, b: number)
multiplicative_expression(id, A, B) :- unary_expression(id, A, B).
multiplicative_expression(id, A, B) :-
    multiplication_expression(id, _, _, A, B).
multiplicative_expression(id, A, B) :- division_expression(id, _, _, A, B).
multiplicative_expression(id, A, B) :- modulo_expression(id, _, _, A, B).

INFIX("multiplication_expression",
      multiplication_expression,
      multiplicative_expression,
      unary_expression,
      "*")
INFIX("division_expression",
      division_expression,
      multiplicative_expression,
      unary_expression,
      "/")
INFIX("modulo_expression",
      modulo_expression,
      multiplicative_expression,
      unary_expression,
      "%")

.decl unary_expression(id: id, a: number, b: number)
unary_expression(e, A, B) :- pre_increment_expression(e, A, B).
unary_expression(e, A, B) :- pre_decrement_expression(e, A, B).
PREFIX("unary_plus_expression", unary_expression, unary_expression, "+")
PREFIX("unary_minus_expression", unary_expression, unary_expression, "-")
unary_expression(e, A, B) :- unary_expression_not_plus_minus(e, A, B).

.decl pre_increment_expression(id: id, a: number, b: number)
PREFIX("pre_increment_expression",
       pre_increment_expression,
       unary_expression,
       "++")

.decl pre_decrement_expression(id: id, a: number, b: number)
PREFIX("pre_decrement_expression",
       pre_decrement_expression,
       unary_expression,
       "--")

.decl unary_expression_not_plus_minus(id: id, a: number, b: number)
unary_expression_not_plus_minus(e, A, B) :- postfix_expression(e, A, B).

PREFIX("bitwise_not_expression",
       unary_expression_not_plus_minus,
       unary_expression,
       "~")
PREFIX("not_expression",
       unary_expression_not_plus_minus,
       unary_expression,
       "!")

unary_expression_not_plus_minus(e, A, B) :- cast_expression(e, A, B).
unary_expression_not_plus_minus(e, A, B) :- switch_expression(e, A, B).

.decl postfix_expression(id: id, a: number, b: number)
postfix_expression(e, A, B) :- primary(e, A, B).
postfix_expression(["identifiers", A, B], A, B) :- expression_name(e, A, B).
postfix_expression(e, A, B) :- post_increment_expression(e, A, B).
postfix_expression(e, A, B) :- post_decrement_expression(e, A, B).

.decl post_increment_expression(id: id, a: number, b: number)

POSTFIX("post_increment_expression",
        post_increment_expression,
        postfix_expression,
        "++")

.decl post_decrement_expression(id: id, a: number, b: number)

POSTFIX("post_decrement_expression",
        post_decrement_expression,
        postfix_expression,
        "--")

.decl cast_expression(id: id, a: number, b: number)
cast_expression(["cast_expression", A, E], A, E) :-
    token_left_paren(A, B),
    primitive_type(_, B, C),
    token_right_paren(C, D),
    unary_expression(_, D, E).
cast_expression(["cast_expression", A, F], A, F) :-
    token_left_paren(A, B),
    reference_type(t, B, C),
    additional_bounds?(b, C, D),
    token_right_paren(D, E),
    unary_expression_not_plus_minus(e, E, F).
cast_expression(["cast_expression", A, F], A, F) :-
    token_left_paren(A, B),
    reference_type(t, B, C),
    additional_bounds?(b, C, D),
    token_right_paren(D, E),
    lambda_expression(e, E, F).

.decl switch_expression(id: id, a: number, b: number)
switch_expression(["switch_expression", A, F], A, F) :-
    token_switch(A, B),
    token_left_paren(B, C),
    expression(_, C, D),
    token_right_paren(D, E),
    switch_block(_, E, F).

.decl constant_expression(id: id, a: number, b: number)
constant_expression(e, A, B) :- expression(e, A, B).

/**
 * Output
 **************************************************************************/

.decl root(id: id)
root(id) :-
    compilation_unit(id, 0, B),
    num_tokens(B).

/* in tree */

.decl in_tree(id: id)
in_tree(id) :- root(id).
in_tree(id) :- in_tree_list([id, _]).

.decl in_tree_list(ids: id_list)
in_tree_list(tail) :- in_tree_list([_, tail]).

in_tree(name) :-
    single_type_import_declaration(id, name, _, _),
    in_tree(id).

in_tree_list(mods),
in_tree(header),
in_tree(body) :-
    method_declaration(id, mods, header, body, _, _),
    in_tree(id).

in_tree(decl),
in_tree(res) :-
    method_header(id, res, decl, _, _),
    in_tree(id).

in_tree(name),
in_tree(initializer) :-
    variable_declarator(id, name, initializer, _, _),
    in_tree(id).

in_tree(expr),
in_tree(statement) :-
    if_then_statement(id, expr, statement, _, _),
    in_tree(id).

in_tree_list(params),
in_tree(name) :-
    method_declarator(id, name, params, _, _),
    in_tree(id).

in_tree(package_decl),
in_tree_list(imports),
in_tree_list(decls) :-
    ordinary_compilation_unit(unit, package_decl, imports, decls, _, _),
    in_tree(unit).

in_tree(args) :-
    method_invocation(id, args, _, _),
    in_tree(id).

in_tree_list(statements) :-
    block(id, statements, _, _),
    in_tree(id).

in_tree_list(cb),
in_tree_list(mods) :-
    normal_class_declaration(decl, mods, cb, _, _),
    in_tree(decl).

in_tree_list(mods),
in_tree(type),
in_tree_list(declarators) :-
    local_variable_declaration(id, mods, type, declarators, _, _),
    in_tree(id).

in_tree_list(children) :-
    argument_list(id, children, _, _),
    in_tree(id).

.output token
.output token_type
.output num_tokens
.output root
.output in_tree
