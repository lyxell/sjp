.type SymbolList = [
    head: symbol,
    tail: SymbolList
]

.type Expression =
      Add                   {e1: Expression, e2: Expression}
    | And                   {e1: Expression, e2: Expression}
    | ArrayInitializer      {e: ExpressionList}
    | Assign                {e1: Expression, e2: Expression}
    | BitwiseAnd            {e1: Expression, e2: Expression}
    | BitwiseExclOr         {e1: Expression, e2: Expression}
    | BitwiseInclOr         {e1: Expression, e2: Expression}
    | BitwiseNot            {e: Expression}
    | Div                   {e1: Expression, e2: Expression}
    | Equal                 {e1: Expression, e2: Expression}
    | Identifier            {id: symbol}
    | LessThan              {e1: Expression, e2: Expression}
    | Mod                   {e1: Expression, e2: Expression}
    | Mul                   {e1: Expression, e2: Expression}
    | Not                   {e: Expression}
    | NotEqual              {e1: Expression, e2: Expression}
    | Number                {n: number}
    | Or                    {e1: Expression, e2: Expression}
    | PostDecrement         {e: Expression}
    | PostIncrement         {e: Expression}
    | PreDecrement          {e: Expression}
    | PreIncrement          {e: Expression}
    | ShiftLeft             {e1: Expression, e2: Expression}
    | ShiftRight            {e1: Expression, e2: Expression}
    | ShiftRightUnsigned    {e1: Expression, e2: Expression}
    | Sub                   {e1: Expression, e2: Expression}
    | SwitchExpr            {e: Expression}

.type ExpressionList = [
    head: Expression,
    tail: ExpressionList
]

.type Type =
      TypeParameter {}
    | Boolean {}
    | Byte {}
    | Short {}
    | Int {}
    | Long {}
    | Char {}
    | Float {}
    | Double {}
         

.type TypeList = [
    head: Type,
    tail: TypeList
]

.type TopLevel = 
      Import                {s: SymbolList}
    | ImportOnDemandFrom    {s: SymbolList}

.type Declaration =
      Class                 {modifiers: SymbolList, id: symbol, l: DeclarationList}
    | Interface             {modifiers: SymbolList, id: symbol}
    | Method                {modifiers: SymbolList, id: symbol}
    | EmptyDeclaration      {}

.type DeclarationList = [
    head: Declaration,
    tail: DeclarationList
]

.type Statement =
      Assert                {e: Expression}
    | AssertDetailed        {e1: Expression, e2: Expression}
    | Block                 {s: StatementList}
    | Do                    {e: Expression, s: Statement}
    | Empty                 {}
    | Label                 {id: symbol, s: Statement}
    | IfThen                {e: Expression, s: Statement}
    | IfThenElse            {e: Expression, s1: Statement, s2: Statement}
    | Return                {e: Expression}
    | ReturnVoid            {}
    | Switch                {e: Expression, s: Statement}
    | While                 {e: Expression, s: Statement}
    | ExpressionStatement   {e: Expression}
    | Yield                 {e: Expression}

.type StatementList = [
    head: Statement,
    tail: StatementList
]

.decl token(s: symbol, c: symbol, n: number)

.decl type_parameter_list(s: TypeList, a: number, b: number)
.decl type_parameters(s: TypeList, a: number, b: number)
.decl type_parameter(s: Type, a: number, b: number)
.decl field_declaration(s: Declaration, a: number, b: number)
.decl method_declaration(s: Declaration, a: number, b: number)
.decl method_body(s: Statement, a: number, b: number)
.decl interface_declaration(s: Declaration, a: number, b: number)
.decl class_declaration(s: Declaration, a: number, b: number)
.decl normal_class_declaration(s: Declaration, a: number, b: number)
.decl class_member_declaration(s: Declaration, a: number, b: number)
.decl enum_declaration(s: Declaration, a: number, b: number)
.decl class_body(s: DeclarationList, a: number, b: number)
.decl class_body_declaration(d: Declaration, a: number, b: number)
.decl instance_initializer(s: Statement, a: number, b: number)
.decl static_initializer(s: Statement, a: number, b: number)
.decl class_body_declarations(d: DeclarationList, a: number, b: number)
.decl variable_initializer(s: Expression, a: number, b: number)
.decl variable_initializer_list(s: ExpressionList, a: number, b: number)

.decl unann_primitive_type(t: Type, a: number, b: number)
.decl unann_type(t: Type, a: number, b: number)
.decl unann_reference_type(t: Type, a: number, b: number)
.decl numeric_type(t: Type, a: number, b: number)
.decl integral_type(t: Type, a: number, b: number)
.decl floating_point_type(t: Type, a: number, b: number)
.decl simple_type_name(s: symbol, l: number, n: number)

.decl class_modifier(s: symbol, a: number, b: number)
.decl class_modifiers(s: SymbolList, a: number, b: number)
.decl type_identifier(s: symbol, l: number, n: number)

.decl type_name(s: SymbolList, a: number, b: number)
.decl package_or_type_name(s: SymbolList, a: number, b: number)
.decl import_declaration(s: TopLevel, a: number, b: number)
.decl single_type_import_declaration(s: TopLevel, a: number, b: number)
.decl type_import_on_demand_declaration(s: TopLevel, a: number, b: number)

.decl block(s: Statement, n: number, l: number)
.decl block_statements(s: StatementList, n: number, l: number)
.decl block_statement(s: Statement, n: number, l: number)
.decl statement(s: Statement, n: number, l: number)
.decl empty_statement(s: Statement, n: number, l: number)
.decl statement_without_trailing_substatement(s: Statement, n: number, l: number)
.decl statement_no_short_if(s: Statement, n: number, l: number)
.decl assert_statement(s: Statement, n: number, l: number)
.decl labeled_statement(s: Statement, n: number, l: number)
.decl labeled_statement_no_short_if(s: Statement, n: number, l: number)
.decl if_then_statement(s: Statement, n: number, l: number)
.decl if_then_else_statement(s: Statement, n: number, l: number)
.decl while_statement(s: Statement, n: number, l: number)
.decl case_constant(e: Expression, n: number, l: number)
.decl switch_block(s: Statement, n: number, l: number)
.decl yield_statement(s: Statement, n: number, l: number)
.decl return_statement(s: Statement, n: number, l: number)
.decl switch_statement(s: Statement, n: number, l: number)
.decl do_statement(s: Statement, n: number, l: number)
.decl expression_statement(e: Statement, n: number, l: number)
.decl statement_expression(e: Expression, n: number, l: number)

.decl expression(e: Expression, n: number, l: number)
.decl array_initializer(e: Expression, a: number, b: number)
.decl inclusive_or_expression(e: Expression, n: number, l: number)
.decl pre_increment_expression(e: Expression, n: number, l: number)
.decl pre_decrement_expression(e: Expression, n: number, l: number)
.decl post_increment_expression(e: Expression, n: number, l: number)
.decl exclusive_or_expression(e: Expression, n: number, l: number)
.decl assignment_expression(e: Expression, n: number, l: number)
.decl conditional_expression(e: Expression, n: number, l: number)
.decl equality_expression(e: Expression, n: number, l: number)
.decl post_decrement_expression(e: Expression, n: number, l: number)
.decl conditional_or_expression(e: Expression, n: number, l: number)
.decl unary_expression_not_plus_minus(e: Expression, n: number, l: number)
.decl postfix_expression(e: Expression, n: number, l: number)
.decl conditional_and_expression(e: Expression, n: number, l: number)
.decl and_expression(e: Expression, n: number, l: number)
.decl relational_expression(e: Expression, n: number, l: number)
.decl shift_expression(e: Expression, n: number, l: number)
.decl expression_name(e: Expression, n: number, l: number)
.decl additive_expression(e: Expression, n: number, l: number)
.decl multiplicative_expression(e: Expression, n: number, l: number)
.decl unary_expression(e: Expression, n: number, l: number)
.decl switch_expression(e: Expression, n: number, l: number)

.decl root(s: Statement)

.input token


/**
 * Helper functions
 **************************************************************************/

.decl any_position(n: number)
any_position(n) :- token(_, _, n).

#define ZERO_OR_MORE(xs, x) \
    xs(nil, A, A) :- any_position(A). \
    xs([e, tail], A, C) :- x(e, A, B), xs(tail, B, C).

/**
 * Lexical structure
 *
 * Adapted from ยง3 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

type_identifier(t, A, A + 1) :-
    token("TOKEN_IDENTIFIER", t, A).
// TODO not var or yield

/**
 * Types, Values and Variables
 *
 * Adapted from ยง4 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

numeric_type(e, A, B) :- integral_type(e, A, B).
numeric_type(e, A, B) :- floating_point_type(e, A, B).

integral_type($Byte, A, A + 1) :- token("TOKEN_KEYWORD", "byte", A).
integral_type($Short, A, A + 1) :- token("TOKEN_KEYWORD", "short", A).
integral_type($Int, A, A + 1) :- token("TOKEN_KEYWORD", "int", A).
integral_type($Long, A, A + 1) :- token("TOKEN_KEYWORD", "long", A).
integral_type($Char, A, A + 1) :- token("TOKEN_KEYWORD", "char", A).

floating_point_type($Float, A, A + 1) :-
    token("TOKEN_KEYWORD", "float", A).
floating_point_type($Double, A, A + 1) :-
    token("TOKEN_KEYWORD", "double", A).

/**
 * Names
 *
 * Adapted from ยง6 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

// TODO ModuleName

// TODO PackageName

type_name([t, nil], A, B) :- type_identifier(t, A, B).
type_name([t, tail], A, C) :-
    package_or_type_name(tail, A, B),
    token("TOKEN_SEPARATOR", ".", B),
    type_identifier(t, B + 1, C).
// ... TODO: reverse?

// TODO ExpressionName

// TODO MethodName

package_or_type_name([t, nil], A, A + 1) :-
    token("IDENTIFIER", t, A).

package_or_type_name([t, tail], A, B + 2) :-
    package_or_type_name(tail, A, B), B > A,
    token("TOKEN_SEPARATOR", ".", B),
    token("IDENTIFIER", t, B + 1).

// TODO AmbiguousName

/**
 * Packages and Modules
 *
 * Adapted from ยง7 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

// TODO CompilationUnit

//compilation_unit(e, A, B) :- ordinary_compilation_unit(e, A, B).

// TODO OrdinaryCompilationUnit

/*
ordinary_compilation_unit(e, A, B) :-
    package_declaration(e, A, B),
    import_declarations(e, A, B),
    import_declarations(e, A, B).*/

// TODO ModularCompilationUnit

// TODO PackageDeclaration

// TODO PackageModifier

import_declaration(e, A, B) :- single_type_import_declaration(e, A, B).
import_declaration(e, A, B) :- type_import_on_demand_declaration(e, A, B).
// ... TODO

single_type_import_declaration($Import(syms), A, B + 1) :-
    token("TOKEN_KEYWORD", "import", A),
    type_name(syms, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ";", B).

type_import_on_demand_declaration($ImportOnDemandFrom(syms), A, B + 3) :-
    token("TOKEN_KEYWORD", "import", A),
    type_name(syms, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ".", B),
    token("TOKEN_OPERATOR",  "*", B + 1),
    token("TOKEN_SEPARATOR", ";", B + 2).

// TODO SingleStaticImportDeclaration

// TODO StaticImportOnDemandDeclaration

// TODO TypeDeclaration

// TODO ModuleDeclaration

// TODO ModuleDirective

// TODO RequiresModifier

/**
 * Classes
 *
 * Adapted from ยง8 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

class_declaration(e, A, B) :- normal_class_declaration(e, A, B).
class_declaration(e, A, B) :- enum_declaration(e, A, B).

normal_class_declaration($Class(modifiers, id, declarations), A, D) :-
    class_modifiers(modifiers, A, B),
    token("TOKEN_KEYWORD", "class", B),
    type_identifier(id, B + 1, C), C > B + 1,
    class_body(declarations, C, D).

ZERO_OR_MORE(class_modifiers, class_modifier)

class_modifier("public", A, A + 1) :- token("TOKEN_KEYWORD", "public", A).
class_modifier("private", A, A + 1) :- token("TOKEN_KEYWORD", "private", A).
class_modifier("protected", A, A + 1) :- token("TOKEN_KEYWORD", "protected", A).

type_parameters(nil, A, A) :- any_position(A).
type_parameters(l, A, B) :-
    token("TOKEN_OPERATOR", "<", A),
    type_parameter_list(l, A + 1, B),
    token("TOKEN_OPERATOR", ">", B).

type_parameter_list([e, nil], A, B) :- type_parameter(e, A, B).
type_parameter_list([e, tail], A, C) :-
    type_parameter(e, A, B),
    token("TOKEN_SEPARATOR", ",", B),
    type_parameter_list(tail, B+1, C).

// TODO Superclass

// TODO Superinterfaces

// TODO InterfaceTypeList

class_body(declarations, A, B + 1) :-
    token("TOKEN_BRACKET", "{", A),
    class_body_declarations(declarations, A + 1, B),
    token("TOKEN_BRACKET", "}", B).

ZERO_OR_MORE(class_body_declarations, class_body_declaration)

class_body_declaration(e, A, B) :- class_member_declaration(e, A, B).
// ... TODO

class_member_declaration(e, A, B) :- field_declaration(e, A, B).
class_member_declaration(e, A, B) :- method_declaration(e, A, B).
class_member_declaration(e, A, B) :- class_declaration(e, A, B).
class_member_declaration(e, A, B) :- interface_declaration(e, A, B).
class_member_declaration($EmptyDeclaration, A, A + 1)
    :- token("TOKEN_SEPARATOR", ";", A).

// TODO FieldDeclaration

// TODO FieldModifier

// TODO VariableDeclaratorList

// TODO VariableDeclarator

// TODO VariableDeclaratorId

variable_initializer(e, A, B) :- expression(e, A, B).
variable_initializer(e, A, B) :- array_initializer(e, A, B).

unann_type(e, A, B) :- unann_primitive_type(e, A, B).
unann_type(e, A, B) :- unann_reference_type(e, A, B).

unann_primitive_type($Boolean, A, A + 1) :-
    token("TOKEN_KEYWORD", "boolean", A).
unann_primitive_type(e, A, B) :- numeric_type(e, A, B).

// TODO UnannReferenceType

// TODO UnannClassOrInterfaceType

// TODO UnannClassType

// TODO UnannInterfaceType

// TODO UnannTypeVariable

// TODO UnannArrayType

// TODO MethodDeclaration

// TODO MethodModifier

// TODO MethodHeader

// TODO Result

// TODO MethodDeclarator

// TODO ReceiverParameter

// TODO FormalParameterList

// TODO FormalParameter

// TODO VariableArityParameter

// TODO VariableModifier

// TODO Throws

// TODO ExceptionTypeList

// TODO ExceptionType

method_body(e, A, B + 1) :-
    block(e, A, B),
    token("TOKEN_SEPARATOR", ";", B).

instance_initializer(e, A, B) :- block(e, A, B).

static_initializer(e, A, B) :-
    token("TOKEN_KEYWORD", "static", A),
    block(e, A + 1, B).
// ... TODO - looses static information

// TODO ConstructorDeclaration

// TODO ConstructorModifier

// TODO ConstructorDeclarator

simple_type_name(e, A, B) :- type_identifier(e, A, B).

// TODO ConstructorBody

// TODO ExplicitConstructorInvocation

// TODO EnumDeclaration

// TODO EnumBody

// TODO EnumConstantList

// TODO EnumConstant

// TODO EnumConstantModifier

// TODO EnumBodyDeclaration

/**
 * Arrays
 *
 * Adapted from ยง10 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

array_initializer($ArrayInitializer(e), A, B + 1) :- 
    token("TOKEN_BRACKET", "{", A),
    variable_initializer_list(e, A + 1, B),
    token("TOKEN_BRACKET", "}", B).
array_initializer($ArrayInitializer(e), A, B + 2) :- 
    token("TOKEN_BRACKET", "{", A),
    variable_initializer_list(e, A + 1, B),
    token("TOKEN_SEPARATOR", ",", B),
    token("TOKEN_BRACKET", "}", B + 1).

variable_initializer_list(nil, A, A) :- any_position(A).
variable_initializer_list([e, tail], A, C) :-
    variable_initializer(e, A, B), B > A,
    token("TOKEN_SEPARATOR", ",", B),
    variable_initializer_list(tail, B, C).
    // TODO, logic here is broken

/**
 * Blocks and Statements
 *
 * Adapted from ยง14 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

block($Block(s), A, B + 1) :-
    token("TOKEN_BRACKET", "{", A),
    block_statements(s, A + 1, B),
    token("TOKEN_BRACKET", "}", B).

ZERO_OR_MORE(block_statements, block_statement)

block_statement(e, A, B) :- statement(e, A, B).
// TODO block_statement(e, A, B) :- class_declaration(e, A, B).

// TODO: LocalVariableDeclarationStatement

// TODO: LocalVariableDeclaration

// TODO: LocalVariableType

statement(e, A, B) :- statement_without_trailing_substatement(e, A, B).
statement(e, A, B) :- if_then_statement(e, A, B).
statement(e, A, B) :- if_then_else_statement(e, A, B).
statement(e, A, B) :- while_statement(e, A, B).
// ... TODO

statement_no_short_if(e, A, B) :- statement(e, A, B).
// ... TODO

statement_without_trailing_substatement(e, A, B) :- block(e, A, B).
statement_without_trailing_substatement(e, A, B) :- empty_statement(e, A, B).
statement_without_trailing_substatement(e, A, B) :- assert_statement(e, A, B).
// ... TODO

empty_statement($Empty, A, A+1) :-
    token("TOKEN_SEPARATOR", ";", A).

labeled_statement($Label(id, st), A, B) :-
    token("TOKEN_IDENTIFIER", id, A),
    token("TOKEN_SEPARATOR", ":", A + 1),
    statement(st, A + 2, B).

labeled_statement_no_short_if($Label(id, st), A, B) :-
    token("TOKEN_IDENTIFIER", id, A),
    token("TOKEN_SEPARATOR", ":", A + 1),
    statement_no_short_if(st, A + 2, B).

expression_statement($ExpressionStatement(e), A, B + 1) :-
    statement_expression(e, A, B),
    token("TOKEN_SEPARATOR", ";", B).

statement_expression(e, A, B) :- pre_increment_expression(e, A, B).
statement_expression(e, A, B) :- pre_decrement_expression(e, A, B).
statement_expression(e, A, B) :- post_increment_expression(e, A, B).
statement_expression(e, A, B) :- post_decrement_expression(e, A, B).
// ... TODO

if_then_statement($IfThen(e, s), A, C) :-
    token("TOKEN_KEYWORD", "if", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e, A + 2, B), B > A + 2,
    token("TOKEN_BRACKET", ")", B),
    statement(s, B + 1, C), C > B + 1.

if_then_else_statement($IfThenElse(e, s1, s2), A, D) :-
    token("TOKEN_KEYWORD", "if", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e, A + 2, B), B > A + 2,
    token("TOKEN_BRACKET", ")", B),
    statement_no_short_if(s1, B + 1, C), C > B + 1,
    token("TOKEN_KEYWORD", "else", C),
    statement(s2, C + 1, D), D > C + 1.

// TODO IfThenElseStatementNoShortIf

assert_statement($Assert(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "assert", A),
    expression(e, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ";", B).
assert_statement($AssertDetailed(e1, e2), A, C + 1) :-
    token("TOKEN_KEYWORD", "assert", A),
    expression(e1, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ":", B),
    expression(e2, B + 1, C), C > B + 1,
    token("TOKEN_SEPARATOR", ";", C).

switch_statement($Switch(e, $Empty), A, C) :-
    token("TOKEN_KEYWORD", "switch", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e, A + 2, B), B > A + 2,
    token("TOKEN_BRACKET", ")", B),
    switch_block($Empty, B + 1, C), C > B + 1.

switch_block($Empty, A, A + 2) :-
    token("TOKEN_BRACKET", "{", A),
    token("TOKEN_BRACKET", "}", A + 1).
// TODO ...

// TODO SwitchRule

// TODO SwitchBlockStatementGroup

// TODO SwitchLabel

case_constant(e, A, B) :- conditional_expression(e, A, B).

while_statement($While(cond, do), A, C) :-
    token("TOKEN_KEYWORD", "while", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(cond, A + 2, B), B > A + 2,
    token("TOKEN_BRACKET", ")", B),
    statement(do, B + 1, C), C > B + 1.

// TODO WhileStatementNoShortIf

do_statement($Do(cond, do), A, C + 2) :-
    token("TOKEN_KEYWORD", "do", A),
    statement(do, A + 1, B),  B > A + 1,
    token("TOKEN_KEYWORD", "while", B),
    token("TOKEN_BRACKET", "(", B + 1),
    expression(cond, B + 2, C), C > B + 2,
    token("TOKEN_BRACKET", ")", C),
    token("TOKEN_SEPARATOR", ";", C + 1).

// TODO ForStatement

// TODO ForStatementNoShortIf

// TODO BasicForStatement

// TODO BasicForStatementNoShortIf

// TODO ForInit

// TODO ForUpdate

// TODO StatementExpressionList

// TODO EnhancedForStatement

// TODO EnhancedForStatementNoShortIf

// TODO BreakStatement

yield_statement($Yield(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "yield", A),
    expression(e, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ";", B).

// TODO ContinueStatement

return_statement($ReturnVoid, A, A + 2) :-
    token("TOKEN_KEYWORD", "return", A),
    token("TOKEN_SEPARATOR", ";", A + 1).
return_statement($Return(e), A, B + 1) :-
    token("TOKEN_KEYWORD", "return", A),
    expression(e, A + 1, B), B > A + 1,
    token("TOKEN_SEPARATOR", ";", B).

// TODO ThrowStatement

// TODO SynchronizedStatement

// TODO TryStatement

// TODO Catches

// TODO CatchClause

// TODO CatchFormalParameter

// TODO CatchType

// TODO Finally

// TODO TryWithResourcesStatement

// TODO ResourceSpecification

// TODO ResourceList

// TODO Resource

/**
 * Expressions
 *
 * Adapted from ยง15 of
 * https://docs.oracle.com/javase/specs/jls/se15/html/jls-19.html
 **************************************************************************/

#define INFIX(node, current_level, next_level, symbol) \
    current_level(node(e1, e2), A, C) :- \
        current_level(e1, A, B), B > A, \
        token("TOKEN_OPERATOR", symbol, B), \
        next_level(e2, B + 1, C), C > B + 1.

#define PREFIX(node, current_level, next_level, symbol) \
    current_level(node(e1), A, B) :- \
        token("TOKEN_OPERATOR", symbol, A), \
        next_level(e1, A + 1, B), B > A + 1.

#define POSTFIX(node, current_level, next_level, symbol) \
    current_level(node(e1), A, B + 1) :- \
        next_level(e1, A, B), B > A, \
        token("TOKEN_OPERATOR", symbol, B).

expression(e, A, B) :- conditional_expression(e, A, B).

assignment_expression(e, A, B) :- conditional_expression(e, A, B).

conditional_expression(e, A, B) :- conditional_or_expression(e, A, B).
conditional_expression(e, A, D) :-
    conditional_or_expression(e, A, B), B > A,
    token("TOKEN_SEPARATOR", "?", B),
    expression(e, B + 1, C), C > B + 1,
    token("TOKEN_SEPARATOR", ":", C),
    conditional_expression(e, C + 1, D), D > C + 1.
// TODO: lambda

conditional_or_expression(e, A, B) :- conditional_and_expression(e, A, B).
INFIX($Or, conditional_or_expression, conditional_and_expression, "||")

conditional_and_expression(e, A, B) :- inclusive_or_expression(e, A, B).
INFIX($And, conditional_and_expression, inclusive_or_expression, "&&")

inclusive_or_expression(e, A, B) :- exclusive_or_expression(e, A, B).
INFIX($BitwiseInclOr, inclusive_or_expression, exclusive_or_expression, "|")

exclusive_or_expression(e, A, B) :- and_expression(e, A, B).
INFIX($BitwiseExclOr, exclusive_or_expression, and_expression, "^")

and_expression(e, A, B) :- equality_expression(e, A, B).
INFIX($BitwiseAnd, and_expression, equality_expression, "&")

equality_expression(e, A, B) :-       relational_expression(e, A, B).
INFIX($Equal,    equality_expression, relational_expression, "==")
INFIX($NotEqual, equality_expression, relational_expression, "!=")

relational_expression(e, A, B) :- shift_expression(e, A, B).

shift_expression(e, A, B) :- additive_expression(e, A, B).
INFIX($ShiftLeft,          shift_expression, additive_expression, "<<")
INFIX($ShiftRight,         shift_expression, additive_expression, ">>")
INFIX($ShiftRightUnsigned, shift_expression, additive_expression, ">>>")

additive_expression(e, A, B) :- multiplicative_expression(e, A, B).
INFIX($Add, additive_expression, multiplicative_expression, "+")
INFIX($Sub, additive_expression, multiplicative_expression, "-")

multiplicative_expression(e, A, B) :- unary_expression(e, A, B).
INFIX($Mul, multiplicative_expression, unary_expression, "*")
INFIX($Div, multiplicative_expression, unary_expression, "/")
INFIX($Mod, multiplicative_expression, unary_expression, "%")

unary_expression(e, A, B) :- postfix_expression(e, A, B).
unary_expression(e, A, B) :- pre_increment_expression(e, A, B).
unary_expression(e, A, B) :- pre_decrement_expression(e, A, B).

PREFIX($PreIncrement, pre_increment_expression, unary_expression, "++")
PREFIX($PreDecrement, pre_decrement_expression, unary_expression, "--")

unary_expression_not_plus_minus(e, A, B) :- postfix_expression(e, A, B).
PREFIX($BitwiseNot, unary_expression_not_plus_minus, unary_expression, "~")
PREFIX($Not, unary_expression_not_plus_minus, unary_expression, "!")

postfix_expression(e, A, B) :- expression_name(e, A, B).
postfix_expression(e, A, B) :- post_increment_expression(e, A, B).
postfix_expression(e, A, B) :- post_decrement_expression(e, A, B).

POSTFIX($PostIncrement, post_increment_expression, postfix_expression, "++")
POSTFIX($PostDecrement, post_decrement_expression, postfix_expression, "--")

// TODO
expression_name($Identifier(id), A, A + 1) :- token("TOKEN_IDENTIFIER", id, A).
expression_name($Number(to_number(n)), A, A + 1) :- token("TOKEN_NUMBER", n, A).

switch_expression($SwitchExpr(e1), A, C) :-
    token("TOKEN_KEYWORD", "switch", A),
    token("TOKEN_BRACKET", "(", A + 1),
    expression(e1, A + 2, B),
    token("TOKEN_BRACKET", ")", B),
    switch_block($Empty, B + 1, C).

/**
 * Root
 **************************************************************************/

root(s) :-
    statement(s, 1, N),
    token("TOKEN_EOF", _, N+1).

.output expression
.output statement
.output class_declaration
.output class_modifiers
.output type_identifier
.output class_body
.output normal_class_declaration
